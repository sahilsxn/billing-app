{"ast":null,"code":"var parse = require('../definition-syntax/parse');\n\nvar MATCH = {\n  type: 'Match'\n};\nvar MISMATCH = {\n  type: 'Mismatch'\n};\nvar DISALLOW_EMPTY = {\n  type: 'DisallowEmpty'\n};\nvar LEFTPARENTHESIS = 40; // (\n\nvar RIGHTPARENTHESIS = 41; // )\n\nfunction createCondition(match, thenBranch, elseBranch) {\n  // reduce node count\n  if (thenBranch === MATCH && elseBranch === MISMATCH) {\n    return match;\n  }\n\n  if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {\n    return match;\n  }\n\n  if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {\n    thenBranch = match.then;\n    match = match.match;\n  }\n\n  return {\n    type: 'If',\n    match: match,\n    then: thenBranch,\n    else: elseBranch\n  };\n}\n\nfunction isFunctionType(name) {\n  return name.length > 2 && name.charCodeAt(name.length - 2) === LEFTPARENTHESIS && name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS;\n}\n\nfunction isEnumCapatible(term) {\n  return term.type === 'Keyword' || term.type === 'AtKeyword' || term.type === 'Function' || term.type === 'Type' && isFunctionType(term.name);\n}\n\nfunction buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {\n  switch (combinator) {\n    case ' ':\n      // Juxtaposing components means that all of them must occur, in the given order.\n      //\n      // a b c\n      // =\n      // match a\n      //   then match b\n      //     then match c\n      //       then MATCH\n      //       else MISMATCH\n      //     else MISMATCH\n      //   else MISMATCH\n      var result = MATCH;\n\n      for (var i = terms.length - 1; i >= 0; i--) {\n        var term = terms[i];\n        result = createCondition(term, result, MISMATCH);\n      }\n\n      ;\n      return result;\n\n    case '|':\n      // A bar (|) separates two or more alternatives: exactly one of them must occur.\n      //\n      // a | b | c\n      // =\n      // match a\n      //   then MATCH\n      //   else match b\n      //     then MATCH\n      //     else match c\n      //       then MATCH\n      //       else MISMATCH\n      var result = MISMATCH;\n      var map = null;\n\n      for (var i = terms.length - 1; i >= 0; i--) {\n        var term = terms[i]; // reduce sequence of keywords into a Enum\n\n        if (isEnumCapatible(term)) {\n          if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {\n            map = Object.create(null);\n            result = createCondition({\n              type: 'Enum',\n              map: map\n            }, MATCH, result);\n          }\n\n          if (map !== null) {\n            var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();\n\n            if (key in map === false) {\n              map[key] = term;\n              continue;\n            }\n          }\n        }\n\n        map = null; // create a new conditonal node\n\n        result = createCondition(term, MATCH, result);\n      }\n\n      ;\n      return result;\n\n    case '&&':\n      // A double ampersand (&&) separates two or more components,\n      // all of which must occur, in any order.\n      // Use MatchOnce for groups with a large number of terms,\n      // since &&-groups produces at least N!-node trees\n      if (terms.length > 5) {\n        return {\n          type: 'MatchOnce',\n          terms: terms,\n          all: true\n        };\n      } // Use a combination tree for groups with small number of terms\n      //\n      // a && b && c\n      // =\n      // match a\n      //   then [b && c]\n      //   else match b\n      //     then [a && c]\n      //     else match c\n      //       then [a && b]\n      //       else MISMATCH\n      //\n      // a && b\n      // =\n      // match a\n      //   then match b\n      //     then MATCH\n      //     else MISMATCH\n      //   else match b\n      //     then match a\n      //       then MATCH\n      //       else MISMATCH\n      //     else MISMATCH\n\n\n      var result = MISMATCH;\n\n      for (var i = terms.length - 1; i >= 0; i--) {\n        var term = terms[i];\n        var thenClause;\n\n        if (terms.length > 1) {\n          thenClause = buildGroupMatchGraph(combinator, terms.filter(function (newGroupTerm) {\n            return newGroupTerm !== term;\n          }), false);\n        } else {\n          thenClause = MATCH;\n        }\n\n        result = createCondition(term, thenClause, result);\n      }\n\n      ;\n      return result;\n\n    case '||':\n      // A double bar (||) separates two or more options:\n      // one or more of them must occur, in any order.\n      // Use MatchOnce for groups with a large number of terms,\n      // since ||-groups produces at least N!-node trees\n      if (terms.length > 5) {\n        return {\n          type: 'MatchOnce',\n          terms: terms,\n          all: false\n        };\n      } // Use a combination tree for groups with small number of terms\n      //\n      // a || b || c\n      // =\n      // match a\n      //   then [b || c]\n      //   else match b\n      //     then [a || c]\n      //     else match c\n      //       then [a || b]\n      //       else MISMATCH\n      //\n      // a || b\n      // =\n      // match a\n      //   then match b\n      //     then MATCH\n      //     else MATCH\n      //   else match b\n      //     then match a\n      //       then MATCH\n      //       else MATCH\n      //     else MISMATCH\n\n\n      var result = atLeastOneTermMatched ? MATCH : MISMATCH;\n\n      for (var i = terms.length - 1; i >= 0; i--) {\n        var term = terms[i];\n        var thenClause;\n\n        if (terms.length > 1) {\n          thenClause = buildGroupMatchGraph(combinator, terms.filter(function (newGroupTerm) {\n            return newGroupTerm !== term;\n          }), true);\n        } else {\n          thenClause = MATCH;\n        }\n\n        result = createCondition(term, thenClause, result);\n      }\n\n      ;\n      return result;\n  }\n}\n\nfunction buildMultiplierMatchGraph(node) {\n  var result = MATCH;\n  var matchTerm = buildMatchGraph(node.term);\n\n  if (node.max === 0) {\n    // disable repeating of empty match to prevent infinite loop\n    matchTerm = createCondition(matchTerm, DISALLOW_EMPTY, MISMATCH); // an occurrence count is not limited, make a cycle;\n    // to collect more terms on each following matching mismatch\n\n    result = createCondition(matchTerm, null, // will be a loop\n    MISMATCH);\n    result.then = createCondition(MATCH, MATCH, result // make a loop\n    );\n\n    if (node.comma) {\n      result.then.else = createCondition({\n        type: 'Comma',\n        syntax: node\n      }, result, MISMATCH);\n    }\n  } else {\n    // create a match node chain for [min .. max] interval with optional matches\n    for (var i = node.min || 1; i <= node.max; i++) {\n      if (node.comma && result !== MATCH) {\n        result = createCondition({\n          type: 'Comma',\n          syntax: node\n        }, result, MISMATCH);\n      }\n\n      result = createCondition(matchTerm, createCondition(MATCH, MATCH, result), MISMATCH);\n    }\n  }\n\n  if (node.min === 0) {\n    // allow zero match\n    result = createCondition(MATCH, MATCH, result);\n  } else {\n    // create a match node chain to collect [0 ... min - 1] required matches\n    for (var i = 0; i < node.min - 1; i++) {\n      if (node.comma && result !== MATCH) {\n        result = createCondition({\n          type: 'Comma',\n          syntax: node\n        }, result, MISMATCH);\n      }\n\n      result = createCondition(matchTerm, result, MISMATCH);\n    }\n  }\n\n  return result;\n}\n\nfunction buildMatchGraph(node) {\n  if (typeof node === 'function') {\n    return {\n      type: 'Generic',\n      fn: node\n    };\n  }\n\n  switch (node.type) {\n    case 'Group':\n      var result = buildGroupMatchGraph(node.combinator, node.terms.map(buildMatchGraph), false);\n\n      if (node.disallowEmpty) {\n        result = createCondition(result, DISALLOW_EMPTY, MISMATCH);\n      }\n\n      return result;\n\n    case 'Multiplier':\n      return buildMultiplierMatchGraph(node);\n\n    case 'Type':\n    case 'Property':\n      return {\n        type: node.type,\n        name: node.name,\n        syntax: node\n      };\n\n    case 'Keyword':\n      return {\n        type: node.type,\n        name: node.name.toLowerCase(),\n        syntax: node\n      };\n\n    case 'AtKeyword':\n      return {\n        type: node.type,\n        name: '@' + node.name.toLowerCase(),\n        syntax: node\n      };\n\n    case 'Function':\n      return {\n        type: node.type,\n        name: node.name.toLowerCase() + '(',\n        syntax: node\n      };\n\n    case 'String':\n      // convert a one char length String to a Token\n      if (node.value.length === 3) {\n        return {\n          type: 'Token',\n          value: node.value.charAt(1),\n          syntax: node\n        };\n      } // otherwise use it as is\n\n\n      return {\n        type: node.type,\n        value: node.value.substr(1, node.value.length - 2).replace(/\\\\'/g, '\\''),\n        syntax: node\n      };\n\n    case 'Token':\n      return {\n        type: node.type,\n        value: node.value,\n        syntax: node\n      };\n\n    case 'Comma':\n      return {\n        type: node.type,\n        syntax: node\n      };\n\n    default:\n      throw new Error('Unknown node type:', node.type);\n  }\n}\n\nmodule.exports = {\n  MATCH: MATCH,\n  MISMATCH: MISMATCH,\n  DISALLOW_EMPTY: DISALLOW_EMPTY,\n  buildMatchGraph: function (syntaxTree, ref) {\n    if (typeof syntaxTree === 'string') {\n      syntaxTree = parse(syntaxTree);\n    }\n\n    return {\n      type: 'MatchGraph',\n      match: buildMatchGraph(syntaxTree),\n      syntax: ref || null,\n      source: syntaxTree\n    };\n  }\n};","map":{"version":3,"sources":["/Users/macbook/Documents/GitHub/React 3/billing-app/node_modules/react-pdf-html/node_modules/css-tree/lib/lexer/match-graph.js"],"names":["parse","require","MATCH","type","MISMATCH","DISALLOW_EMPTY","LEFTPARENTHESIS","RIGHTPARENTHESIS","createCondition","match","thenBranch","elseBranch","else","then","isFunctionType","name","length","charCodeAt","isEnumCapatible","term","buildGroupMatchGraph","combinator","terms","atLeastOneTermMatched","result","i","map","Object","create","key","slice","toLowerCase","all","thenClause","filter","newGroupTerm","buildMultiplierMatchGraph","node","matchTerm","buildMatchGraph","max","comma","syntax","min","fn","disallowEmpty","value","charAt","substr","replace","Error","module","exports","syntaxTree","ref","source"],"mappings":"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","sourcesContent":["var parse = require('../definition-syntax/parse');\n\nvar MATCH = { type: 'Match' };\nvar MISMATCH = { type: 'Mismatch' };\nvar DISALLOW_EMPTY = { type: 'DisallowEmpty' };\nvar LEFTPARENTHESIS = 40;  // (\nvar RIGHTPARENTHESIS = 41; // )\n\nfunction createCondition(match, thenBranch, elseBranch) {\n    // reduce node count\n    if (thenBranch === MATCH && elseBranch === MISMATCH) {\n        return match;\n    }\n\n    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {\n        return match;\n    }\n\n    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {\n        thenBranch = match.then;\n        match = match.match;\n    }\n\n    return {\n        type: 'If',\n        match: match,\n        then: thenBranch,\n        else: elseBranch\n    };\n}\n\nfunction isFunctionType(name) {\n    return (\n        name.length > 2 &&\n        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS &&\n        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS\n    );\n}\n\nfunction isEnumCapatible(term) {\n    return (\n        term.type === 'Keyword' ||\n        term.type === 'AtKeyword' ||\n        term.type === 'Function' ||\n        term.type === 'Type' && isFunctionType(term.name)\n    );\n}\n\nfunction buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {\n    switch (combinator) {\n        case ' ':\n            // Juxtaposing components means that all of them must occur, in the given order.\n            //\n            // a b c\n            // =\n            // match a\n            //   then match b\n            //     then match c\n            //       then MATCH\n            //       else MISMATCH\n            //     else MISMATCH\n            //   else MISMATCH\n            var result = MATCH;\n\n            for (var i = terms.length - 1; i >= 0; i--) {\n                var term = terms[i];\n\n                result = createCondition(\n                    term,\n                    result,\n                    MISMATCH\n                );\n            };\n\n            return result;\n\n        case '|':\n            // A bar (|) separates two or more alternatives: exactly one of them must occur.\n            //\n            // a | b | c\n            // =\n            // match a\n            //   then MATCH\n            //   else match b\n            //     then MATCH\n            //     else match c\n            //       then MATCH\n            //       else MISMATCH\n\n            var result = MISMATCH;\n            var map = null;\n\n            for (var i = terms.length - 1; i >= 0; i--) {\n                var term = terms[i];\n\n                // reduce sequence of keywords into a Enum\n                if (isEnumCapatible(term)) {\n                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {\n                        map = Object.create(null);\n                        result = createCondition(\n                            {\n                                type: 'Enum',\n                                map: map\n                            },\n                            MATCH,\n                            result\n                        );\n                    }\n\n                    if (map !== null) {\n                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();\n                        if (key in map === false) {\n                            map[key] = term;\n                            continue;\n                        }\n                    }\n                }\n\n                map = null;\n\n                // create a new conditonal node\n                result = createCondition(\n                    term,\n                    MATCH,\n                    result\n                );\n            };\n\n            return result;\n\n        case '&&':\n            // A double ampersand (&&) separates two or more components,\n            // all of which must occur, in any order.\n\n            // Use MatchOnce for groups with a large number of terms,\n            // since &&-groups produces at least N!-node trees\n            if (terms.length > 5) {\n                return {\n                    type: 'MatchOnce',\n                    terms: terms,\n                    all: true\n                };\n            }\n\n            // Use a combination tree for groups with small number of terms\n            //\n            // a && b && c\n            // =\n            // match a\n            //   then [b && c]\n            //   else match b\n            //     then [a && c]\n            //     else match c\n            //       then [a && b]\n            //       else MISMATCH\n            //\n            // a && b\n            // =\n            // match a\n            //   then match b\n            //     then MATCH\n            //     else MISMATCH\n            //   else match b\n            //     then match a\n            //       then MATCH\n            //       else MISMATCH\n            //     else MISMATCH\n            var result = MISMATCH;\n\n            for (var i = terms.length - 1; i >= 0; i--) {\n                var term = terms[i];\n                var thenClause;\n\n                if (terms.length > 1) {\n                    thenClause = buildGroupMatchGraph(\n                        combinator,\n                        terms.filter(function(newGroupTerm) {\n                            return newGroupTerm !== term;\n                        }),\n                        false\n                    );\n                } else {\n                    thenClause = MATCH;\n                }\n\n                result = createCondition(\n                    term,\n                    thenClause,\n                    result\n                );\n            };\n\n            return result;\n\n        case '||':\n            // A double bar (||) separates two or more options:\n            // one or more of them must occur, in any order.\n\n            // Use MatchOnce for groups with a large number of terms,\n            // since ||-groups produces at least N!-node trees\n            if (terms.length > 5) {\n                return {\n                    type: 'MatchOnce',\n                    terms: terms,\n                    all: false\n                };\n            }\n\n            // Use a combination tree for groups with small number of terms\n            //\n            // a || b || c\n            // =\n            // match a\n            //   then [b || c]\n            //   else match b\n            //     then [a || c]\n            //     else match c\n            //       then [a || b]\n            //       else MISMATCH\n            //\n            // a || b\n            // =\n            // match a\n            //   then match b\n            //     then MATCH\n            //     else MATCH\n            //   else match b\n            //     then match a\n            //       then MATCH\n            //       else MATCH\n            //     else MISMATCH\n            var result = atLeastOneTermMatched ? MATCH : MISMATCH;\n\n            for (var i = terms.length - 1; i >= 0; i--) {\n                var term = terms[i];\n                var thenClause;\n\n                if (terms.length > 1) {\n                    thenClause = buildGroupMatchGraph(\n                        combinator,\n                        terms.filter(function(newGroupTerm) {\n                            return newGroupTerm !== term;\n                        }),\n                        true\n                    );\n                } else {\n                    thenClause = MATCH;\n                }\n\n                result = createCondition(\n                    term,\n                    thenClause,\n                    result\n                );\n            };\n\n            return result;\n    }\n}\n\nfunction buildMultiplierMatchGraph(node) {\n    var result = MATCH;\n    var matchTerm = buildMatchGraph(node.term);\n\n    if (node.max === 0) {\n        // disable repeating of empty match to prevent infinite loop\n        matchTerm = createCondition(\n            matchTerm,\n            DISALLOW_EMPTY,\n            MISMATCH\n        );\n\n        // an occurrence count is not limited, make a cycle;\n        // to collect more terms on each following matching mismatch\n        result = createCondition(\n            matchTerm,\n            null, // will be a loop\n            MISMATCH\n        );\n\n        result.then = createCondition(\n            MATCH,\n            MATCH,\n            result // make a loop\n        );\n\n        if (node.comma) {\n            result.then.else = createCondition(\n                { type: 'Comma', syntax: node },\n                result,\n                MISMATCH\n            );\n        }\n    } else {\n        // create a match node chain for [min .. max] interval with optional matches\n        for (var i = node.min || 1; i <= node.max; i++) {\n            if (node.comma && result !== MATCH) {\n                result = createCondition(\n                    { type: 'Comma', syntax: node },\n                    result,\n                    MISMATCH\n                );\n            }\n\n            result = createCondition(\n                matchTerm,\n                createCondition(\n                    MATCH,\n                    MATCH,\n                    result\n                ),\n                MISMATCH\n            );\n        }\n    }\n\n    if (node.min === 0) {\n        // allow zero match\n        result = createCondition(\n            MATCH,\n            MATCH,\n            result\n        );\n    } else {\n        // create a match node chain to collect [0 ... min - 1] required matches\n        for (var i = 0; i < node.min - 1; i++) {\n            if (node.comma && result !== MATCH) {\n                result = createCondition(\n                    { type: 'Comma', syntax: node },\n                    result,\n                    MISMATCH\n                );\n            }\n\n            result = createCondition(\n                matchTerm,\n                result,\n                MISMATCH\n            );\n        }\n    }\n\n    return result;\n}\n\nfunction buildMatchGraph(node) {\n    if (typeof node === 'function') {\n        return {\n            type: 'Generic',\n            fn: node\n        };\n    }\n\n    switch (node.type) {\n        case 'Group':\n            var result = buildGroupMatchGraph(\n                node.combinator,\n                node.terms.map(buildMatchGraph),\n                false\n            );\n\n            if (node.disallowEmpty) {\n                result = createCondition(\n                    result,\n                    DISALLOW_EMPTY,\n                    MISMATCH\n                );\n            }\n\n            return result;\n\n        case 'Multiplier':\n            return buildMultiplierMatchGraph(node);\n\n        case 'Type':\n        case 'Property':\n            return {\n                type: node.type,\n                name: node.name,\n                syntax: node\n            };\n\n        case 'Keyword':\n            return {\n                type: node.type,\n                name: node.name.toLowerCase(),\n                syntax: node\n            };\n\n        case 'AtKeyword':\n            return {\n                type: node.type,\n                name: '@' + node.name.toLowerCase(),\n                syntax: node\n            };\n\n        case 'Function':\n            return {\n                type: node.type,\n                name: node.name.toLowerCase() + '(',\n                syntax: node\n            };\n\n        case 'String':\n            // convert a one char length String to a Token\n            if (node.value.length === 3) {\n                return {\n                    type: 'Token',\n                    value: node.value.charAt(1),\n                    syntax: node\n                };\n            }\n\n            // otherwise use it as is\n            return {\n                type: node.type,\n                value: node.value.substr(1, node.value.length - 2).replace(/\\\\'/g, '\\''),\n                syntax: node\n            };\n\n        case 'Token':\n            return {\n                type: node.type,\n                value: node.value,\n                syntax: node\n            };\n\n        case 'Comma':\n            return {\n                type: node.type,\n                syntax: node\n            };\n\n        default:\n            throw new Error('Unknown node type:', node.type);\n    }\n}\n\nmodule.exports = {\n    MATCH: MATCH,\n    MISMATCH: MISMATCH,\n    DISALLOW_EMPTY: DISALLOW_EMPTY,\n    buildMatchGraph: function(syntaxTree, ref) {\n        if (typeof syntaxTree === 'string') {\n            syntaxTree = parse(syntaxTree);\n        }\n\n        return {\n            type: 'MatchGraph',\n            match: buildMatchGraph(syntaxTree),\n            syntax: ref || null,\n            source: syntaxTree\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}