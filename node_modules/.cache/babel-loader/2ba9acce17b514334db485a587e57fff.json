{"ast":null,"code":"var List = require('../common/List');\n\nfunction getFirstMatchNode(matchNode) {\n  if ('node' in matchNode) {\n    return matchNode.node;\n  }\n\n  return getFirstMatchNode(matchNode.match[0]);\n}\n\nfunction getLastMatchNode(matchNode) {\n  if ('node' in matchNode) {\n    return matchNode.node;\n  }\n\n  return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);\n}\n\nfunction matchFragments(lexer, ast, match, type, name) {\n  function findFragments(matchNode) {\n    if (matchNode.syntax !== null && matchNode.syntax.type === type && matchNode.syntax.name === name) {\n      var start = getFirstMatchNode(matchNode);\n      var end = getLastMatchNode(matchNode);\n      lexer.syntax.walk(ast, function (node, item, list) {\n        if (node === start) {\n          var nodes = new List();\n\n          do {\n            nodes.appendData(item.data);\n\n            if (item.data === end) {\n              break;\n            }\n\n            item = item.next;\n          } while (item !== null);\n\n          fragments.push({\n            parent: list,\n            nodes: nodes\n          });\n        }\n      });\n    }\n\n    if (Array.isArray(matchNode.match)) {\n      matchNode.match.forEach(findFragments);\n    }\n  }\n\n  var fragments = [];\n\n  if (match.matched !== null) {\n    findFragments(match.matched);\n  }\n\n  return fragments;\n}\n\nmodule.exports = {\n  matchFragments: matchFragments\n};","map":{"version":3,"sources":["/Users/macbook/Documents/GitHub/React 3/billing-app/node_modules/react-pdf-html/node_modules/css-tree/lib/lexer/search.js"],"names":["List","require","getFirstMatchNode","matchNode","node","match","getLastMatchNode","length","matchFragments","lexer","ast","type","name","findFragments","syntax","start","end","walk","item","list","nodes","appendData","data","next","fragments","push","parent","Array","isArray","forEach","matched","module","exports"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,OAAO,CAAC,gBAAD,CAAlB;;AAEA,SAASC,iBAAT,CAA2BC,SAA3B,EAAsC;AAClC,MAAI,UAAUA,SAAd,EAAyB;AACrB,WAAOA,SAAS,CAACC,IAAjB;AACH;;AAED,SAAOF,iBAAiB,CAACC,SAAS,CAACE,KAAV,CAAgB,CAAhB,CAAD,CAAxB;AACH;;AAED,SAASC,gBAAT,CAA0BH,SAA1B,EAAqC;AACjC,MAAI,UAAUA,SAAd,EAAyB;AACrB,WAAOA,SAAS,CAACC,IAAjB;AACH;;AAED,SAAOE,gBAAgB,CAACH,SAAS,CAACE,KAAV,CAAgBF,SAAS,CAACE,KAAV,CAAgBE,MAAhB,GAAyB,CAAzC,CAAD,CAAvB;AACH;;AAED,SAASC,cAAT,CAAwBC,KAAxB,EAA+BC,GAA/B,EAAoCL,KAApC,EAA2CM,IAA3C,EAAiDC,IAAjD,EAAuD;AACnD,WAASC,aAAT,CAAuBV,SAAvB,EAAkC;AAC9B,QAAIA,SAAS,CAACW,MAAV,KAAqB,IAArB,IACAX,SAAS,CAACW,MAAV,CAAiBH,IAAjB,KAA0BA,IAD1B,IAEAR,SAAS,CAACW,MAAV,CAAiBF,IAAjB,KAA0BA,IAF9B,EAEoC;AAChC,UAAIG,KAAK,GAAGb,iBAAiB,CAACC,SAAD,CAA7B;AACA,UAAIa,GAAG,GAAGV,gBAAgB,CAACH,SAAD,CAA1B;AAEAM,MAAAA,KAAK,CAACK,MAAN,CAAaG,IAAb,CAAkBP,GAAlB,EAAuB,UAASN,IAAT,EAAec,IAAf,EAAqBC,IAArB,EAA2B;AAC9C,YAAIf,IAAI,KAAKW,KAAb,EAAoB;AAChB,cAAIK,KAAK,GAAG,IAAIpB,IAAJ,EAAZ;;AAEA,aAAG;AACCoB,YAAAA,KAAK,CAACC,UAAN,CAAiBH,IAAI,CAACI,IAAtB;;AAEA,gBAAIJ,IAAI,CAACI,IAAL,KAAcN,GAAlB,EAAuB;AACnB;AACH;;AAEDE,YAAAA,IAAI,GAAGA,IAAI,CAACK,IAAZ;AACH,WARD,QAQSL,IAAI,KAAK,IARlB;;AAUAM,UAAAA,SAAS,CAACC,IAAV,CAAe;AACXC,YAAAA,MAAM,EAAEP,IADG;AAEXC,YAAAA,KAAK,EAAEA;AAFI,WAAf;AAIH;AACJ,OAnBD;AAoBH;;AAED,QAAIO,KAAK,CAACC,OAAN,CAAczB,SAAS,CAACE,KAAxB,CAAJ,EAAoC;AAChCF,MAAAA,SAAS,CAACE,KAAV,CAAgBwB,OAAhB,CAAwBhB,aAAxB;AACH;AACJ;;AAED,MAAIW,SAAS,GAAG,EAAhB;;AAEA,MAAInB,KAAK,CAACyB,OAAN,KAAkB,IAAtB,EAA4B;AACxBjB,IAAAA,aAAa,CAACR,KAAK,CAACyB,OAAP,CAAb;AACH;;AAED,SAAON,SAAP;AACH;;AAEDO,MAAM,CAACC,OAAP,GAAiB;AACbxB,EAAAA,cAAc,EAAEA;AADH,CAAjB","sourcesContent":["var List = require('../common/List');\n\nfunction getFirstMatchNode(matchNode) {\n    if ('node' in matchNode) {\n        return matchNode.node;\n    }\n\n    return getFirstMatchNode(matchNode.match[0]);\n}\n\nfunction getLastMatchNode(matchNode) {\n    if ('node' in matchNode) {\n        return matchNode.node;\n    }\n\n    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);\n}\n\nfunction matchFragments(lexer, ast, match, type, name) {\n    function findFragments(matchNode) {\n        if (matchNode.syntax !== null &&\n            matchNode.syntax.type === type &&\n            matchNode.syntax.name === name) {\n            var start = getFirstMatchNode(matchNode);\n            var end = getLastMatchNode(matchNode);\n\n            lexer.syntax.walk(ast, function(node, item, list) {\n                if (node === start) {\n                    var nodes = new List();\n\n                    do {\n                        nodes.appendData(item.data);\n\n                        if (item.data === end) {\n                            break;\n                        }\n\n                        item = item.next;\n                    } while (item !== null);\n\n                    fragments.push({\n                        parent: list,\n                        nodes: nodes\n                    });\n                }\n            });\n        }\n\n        if (Array.isArray(matchNode.match)) {\n            matchNode.match.forEach(findFragments);\n        }\n    }\n\n    var fragments = [];\n\n    if (match.matched !== null) {\n        findFragments(match.matched);\n    }\n\n    return fragments;\n}\n\nmodule.exports = {\n    matchFragments: matchFragments\n};\n"]},"metadata":{},"sourceType":"script"}