{"ast":null,"code":"var OffsetToLocation = require('../common/OffsetToLocation');\n\nvar SyntaxError = require('../common/SyntaxError');\n\nvar TokenStream = require('../common/TokenStream');\n\nvar List = require('../common/List');\n\nvar tokenize = require('../tokenizer');\n\nvar constants = require('../tokenizer/const');\n\nvar {\n  findWhiteSpaceStart,\n  cmpStr\n} = require('../tokenizer/utils');\n\nvar sequence = require('./sequence');\n\nvar noop = function () {};\n\nvar TYPE = constants.TYPE;\nvar NAME = constants.NAME;\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\nvar IDENT = TYPE.Ident;\nvar FUNCTION = TYPE.Function;\nvar URL = TYPE.Url;\nvar HASH = TYPE.Hash;\nvar PERCENTAGE = TYPE.Percentage;\nvar NUMBER = TYPE.Number;\nvar NUMBERSIGN = 0x0023; // U+0023 NUMBER SIGN (#)\n\nvar NULL = 0;\n\nfunction createParseContext(name) {\n  return function () {\n    return this[name]();\n  };\n}\n\nfunction processConfig(config) {\n  var parserConfig = {\n    context: {},\n    scope: {},\n    atrule: {},\n    pseudo: {}\n  };\n\n  if (config.parseContext) {\n    for (var name in config.parseContext) {\n      switch (typeof config.parseContext[name]) {\n        case 'function':\n          parserConfig.context[name] = config.parseContext[name];\n          break;\n\n        case 'string':\n          parserConfig.context[name] = createParseContext(config.parseContext[name]);\n          break;\n      }\n    }\n  }\n\n  if (config.scope) {\n    for (var name in config.scope) {\n      parserConfig.scope[name] = config.scope[name];\n    }\n  }\n\n  if (config.atrule) {\n    for (var name in config.atrule) {\n      var atrule = config.atrule[name];\n\n      if (atrule.parse) {\n        parserConfig.atrule[name] = atrule.parse;\n      }\n    }\n  }\n\n  if (config.pseudo) {\n    for (var name in config.pseudo) {\n      var pseudo = config.pseudo[name];\n\n      if (pseudo.parse) {\n        parserConfig.pseudo[name] = pseudo.parse;\n      }\n    }\n  }\n\n  if (config.node) {\n    for (var name in config.node) {\n      parserConfig[name] = config.node[name].parse;\n    }\n  }\n\n  return parserConfig;\n}\n\nmodule.exports = function createParser(config) {\n  var parser = {\n    scanner: new TokenStream(),\n    locationMap: new OffsetToLocation(),\n    filename: '<unknown>',\n    needPositions: false,\n    onParseError: noop,\n    onParseErrorThrow: false,\n    parseAtrulePrelude: true,\n    parseRulePrelude: true,\n    parseValue: true,\n    parseCustomProperty: false,\n    readSequence: sequence,\n    createList: function () {\n      return new List();\n    },\n    createSingleNodeList: function (node) {\n      return new List().appendData(node);\n    },\n    getFirstListNode: function (list) {\n      return list && list.first();\n    },\n    getLastListNode: function (list) {\n      return list.last();\n    },\n    parseWithFallback: function (consumer, fallback) {\n      var startToken = this.scanner.tokenIndex;\n\n      try {\n        return consumer.call(this);\n      } catch (e) {\n        if (this.onParseErrorThrow) {\n          throw e;\n        }\n\n        var fallbackNode = fallback.call(this, startToken);\n        this.onParseErrorThrow = true;\n        this.onParseError(e, fallbackNode);\n        this.onParseErrorThrow = false;\n        return fallbackNode;\n      }\n    },\n    lookupNonWSType: function (offset) {\n      do {\n        var type = this.scanner.lookupType(offset++);\n\n        if (type !== WHITESPACE) {\n          return type;\n        }\n      } while (type !== NULL);\n\n      return NULL;\n    },\n    eat: function (tokenType) {\n      if (this.scanner.tokenType !== tokenType) {\n        var offset = this.scanner.tokenStart;\n        var message = NAME[tokenType] + ' is expected'; // tweak message and offset\n\n        switch (tokenType) {\n          case IDENT:\n            // when identifier is expected but there is a function or url\n            if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL) {\n              offset = this.scanner.tokenEnd - 1;\n              message = 'Identifier is expected but function found';\n            } else {\n              message = 'Identifier is expected';\n            }\n\n            break;\n\n          case HASH:\n            if (this.scanner.isDelim(NUMBERSIGN)) {\n              this.scanner.next();\n              offset++;\n              message = 'Name is expected';\n            }\n\n            break;\n\n          case PERCENTAGE:\n            if (this.scanner.tokenType === NUMBER) {\n              offset = this.scanner.tokenEnd;\n              message = 'Percent sign is expected';\n            }\n\n            break;\n\n          default:\n            // when test type is part of another token show error for current position + 1\n            // e.g. eat(HYPHENMINUS) will fail on \"-foo\", but pointing on \"-\" is odd\n            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {\n              offset = offset + 1;\n            }\n\n        }\n\n        this.error(message, offset);\n      }\n\n      this.scanner.next();\n    },\n    consume: function (tokenType) {\n      var value = this.scanner.getTokenValue();\n      this.eat(tokenType);\n      return value;\n    },\n    consumeFunctionName: function () {\n      var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);\n      this.eat(FUNCTION);\n      return name;\n    },\n    getLocation: function (start, end) {\n      if (this.needPositions) {\n        return this.locationMap.getLocationRange(start, end, this.filename);\n      }\n\n      return null;\n    },\n    getLocationFromList: function (list) {\n      if (this.needPositions) {\n        var head = this.getFirstListNode(list);\n        var tail = this.getLastListNode(list);\n        return this.locationMap.getLocationRange(head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart, tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart, this.filename);\n      }\n\n      return null;\n    },\n    error: function (message, offset) {\n      var location = typeof offset !== 'undefined' && offset < this.scanner.source.length ? this.locationMap.getLocation(offset) : this.scanner.eof ? this.locationMap.getLocation(findWhiteSpaceStart(this.scanner.source, this.scanner.source.length - 1)) : this.locationMap.getLocation(this.scanner.tokenStart);\n      throw new SyntaxError(message || 'Unexpected input', this.scanner.source, location.offset, location.line, location.column);\n    }\n  };\n  config = processConfig(config || {});\n\n  for (var key in config) {\n    parser[key] = config[key];\n  }\n\n  return function (source, options) {\n    options = options || {};\n    var context = options.context || 'default';\n    var onComment = options.onComment;\n    var ast;\n    tokenize(source, parser.scanner);\n    parser.locationMap.setSource(source, options.offset, options.line, options.column);\n    parser.filename = options.filename || '<unknown>';\n    parser.needPositions = Boolean(options.positions);\n    parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop;\n    parser.onParseErrorThrow = false;\n    parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;\n    parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;\n    parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;\n    parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;\n\n    if (!parser.context.hasOwnProperty(context)) {\n      throw new Error('Unknown context `' + context + '`');\n    }\n\n    if (typeof onComment === 'function') {\n      parser.scanner.forEachToken((type, start, end) => {\n        if (type === COMMENT) {\n          const loc = parser.getLocation(start, end);\n          const value = cmpStr(source, end - 2, end, '*/') ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);\n          onComment(value, loc);\n        }\n      });\n    }\n\n    ast = parser.context[context].call(parser, options);\n\n    if (!parser.scanner.eof) {\n      parser.error();\n    }\n\n    return ast;\n  };\n};","map":{"version":3,"sources":["/Users/macbook/Documents/GitHub/React 3/billing-app/node_modules/react-pdf-html/node_modules/css-tree/lib/parser/create.js"],"names":["OffsetToLocation","require","SyntaxError","TokenStream","List","tokenize","constants","findWhiteSpaceStart","cmpStr","sequence","noop","TYPE","NAME","WHITESPACE","WhiteSpace","COMMENT","Comment","IDENT","Ident","FUNCTION","Function","URL","Url","HASH","Hash","PERCENTAGE","Percentage","NUMBER","Number","NUMBERSIGN","NULL","createParseContext","name","processConfig","config","parserConfig","context","scope","atrule","pseudo","parseContext","parse","node","module","exports","createParser","parser","scanner","locationMap","filename","needPositions","onParseError","onParseErrorThrow","parseAtrulePrelude","parseRulePrelude","parseValue","parseCustomProperty","readSequence","createList","createSingleNodeList","appendData","getFirstListNode","list","first","getLastListNode","last","parseWithFallback","consumer","fallback","startToken","tokenIndex","call","e","fallbackNode","lookupNonWSType","offset","type","lookupType","eat","tokenType","tokenStart","message","tokenEnd","isDelim","next","source","charCodeAt","error","consume","value","getTokenValue","consumeFunctionName","substring","getLocation","start","end","getLocationRange","getLocationFromList","head","tail","loc","startOffset","location","length","eof","line","column","key","options","onComment","ast","setSource","Boolean","positions","hasOwnProperty","Error","forEachToken","slice"],"mappings":"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","sourcesContent":["var OffsetToLocation = require('../common/OffsetToLocation');\nvar SyntaxError = require('../common/SyntaxError');\nvar TokenStream = require('../common/TokenStream');\nvar List = require('../common/List');\nvar tokenize = require('../tokenizer');\nvar constants = require('../tokenizer/const');\nvar { findWhiteSpaceStart, cmpStr } = require('../tokenizer/utils');\nvar sequence = require('./sequence');\nvar noop = function() {};\n\nvar TYPE = constants.TYPE;\nvar NAME = constants.NAME;\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\nvar IDENT = TYPE.Ident;\nvar FUNCTION = TYPE.Function;\nvar URL = TYPE.Url;\nvar HASH = TYPE.Hash;\nvar PERCENTAGE = TYPE.Percentage;\nvar NUMBER = TYPE.Number;\nvar NUMBERSIGN = 0x0023; // U+0023 NUMBER SIGN (#)\nvar NULL = 0;\n\nfunction createParseContext(name) {\n    return function() {\n        return this[name]();\n    };\n}\n\nfunction processConfig(config) {\n    var parserConfig = {\n        context: {},\n        scope: {},\n        atrule: {},\n        pseudo: {}\n    };\n\n    if (config.parseContext) {\n        for (var name in config.parseContext) {\n            switch (typeof config.parseContext[name]) {\n                case 'function':\n                    parserConfig.context[name] = config.parseContext[name];\n                    break;\n\n                case 'string':\n                    parserConfig.context[name] = createParseContext(config.parseContext[name]);\n                    break;\n            }\n        }\n    }\n\n    if (config.scope) {\n        for (var name in config.scope) {\n            parserConfig.scope[name] = config.scope[name];\n        }\n    }\n\n    if (config.atrule) {\n        for (var name in config.atrule) {\n            var atrule = config.atrule[name];\n\n            if (atrule.parse) {\n                parserConfig.atrule[name] = atrule.parse;\n            }\n        }\n    }\n\n    if (config.pseudo) {\n        for (var name in config.pseudo) {\n            var pseudo = config.pseudo[name];\n\n            if (pseudo.parse) {\n                parserConfig.pseudo[name] = pseudo.parse;\n            }\n        }\n    }\n\n    if (config.node) {\n        for (var name in config.node) {\n            parserConfig[name] = config.node[name].parse;\n        }\n    }\n\n    return parserConfig;\n}\n\nmodule.exports = function createParser(config) {\n    var parser = {\n        scanner: new TokenStream(),\n        locationMap: new OffsetToLocation(),\n\n        filename: '<unknown>',\n        needPositions: false,\n        onParseError: noop,\n        onParseErrorThrow: false,\n        parseAtrulePrelude: true,\n        parseRulePrelude: true,\n        parseValue: true,\n        parseCustomProperty: false,\n\n        readSequence: sequence,\n\n        createList: function() {\n            return new List();\n        },\n        createSingleNodeList: function(node) {\n            return new List().appendData(node);\n        },\n        getFirstListNode: function(list) {\n            return list && list.first();\n        },\n        getLastListNode: function(list) {\n            return list.last();\n        },\n\n        parseWithFallback: function(consumer, fallback) {\n            var startToken = this.scanner.tokenIndex;\n\n            try {\n                return consumer.call(this);\n            } catch (e) {\n                if (this.onParseErrorThrow) {\n                    throw e;\n                }\n\n                var fallbackNode = fallback.call(this, startToken);\n\n                this.onParseErrorThrow = true;\n                this.onParseError(e, fallbackNode);\n                this.onParseErrorThrow = false;\n\n                return fallbackNode;\n            }\n        },\n\n        lookupNonWSType: function(offset) {\n            do {\n                var type = this.scanner.lookupType(offset++);\n                if (type !== WHITESPACE) {\n                    return type;\n                }\n            } while (type !== NULL);\n\n            return NULL;\n        },\n\n        eat: function(tokenType) {\n            if (this.scanner.tokenType !== tokenType) {\n                var offset = this.scanner.tokenStart;\n                var message = NAME[tokenType] + ' is expected';\n\n                // tweak message and offset\n                switch (tokenType) {\n                    case IDENT:\n                        // when identifier is expected but there is a function or url\n                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL) {\n                            offset = this.scanner.tokenEnd - 1;\n                            message = 'Identifier is expected but function found';\n                        } else {\n                            message = 'Identifier is expected';\n                        }\n                        break;\n\n                    case HASH:\n                        if (this.scanner.isDelim(NUMBERSIGN)) {\n                            this.scanner.next();\n                            offset++;\n                            message = 'Name is expected';\n                        }\n                        break;\n\n                    case PERCENTAGE:\n                        if (this.scanner.tokenType === NUMBER) {\n                            offset = this.scanner.tokenEnd;\n                            message = 'Percent sign is expected';\n                        }\n                        break;\n\n                    default:\n                        // when test type is part of another token show error for current position + 1\n                        // e.g. eat(HYPHENMINUS) will fail on \"-foo\", but pointing on \"-\" is odd\n                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {\n                            offset = offset + 1;\n                        }\n                }\n\n                this.error(message, offset);\n            }\n\n            this.scanner.next();\n        },\n\n        consume: function(tokenType) {\n            var value = this.scanner.getTokenValue();\n\n            this.eat(tokenType);\n\n            return value;\n        },\n        consumeFunctionName: function() {\n            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);\n\n            this.eat(FUNCTION);\n\n            return name;\n        },\n\n        getLocation: function(start, end) {\n            if (this.needPositions) {\n                return this.locationMap.getLocationRange(\n                    start,\n                    end,\n                    this.filename\n                );\n            }\n\n            return null;\n        },\n        getLocationFromList: function(list) {\n            if (this.needPositions) {\n                var head = this.getFirstListNode(list);\n                var tail = this.getLastListNode(list);\n                return this.locationMap.getLocationRange(\n                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,\n                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,\n                    this.filename\n                );\n            }\n\n            return null;\n        },\n\n        error: function(message, offset) {\n            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length\n                ? this.locationMap.getLocation(offset)\n                : this.scanner.eof\n                    ? this.locationMap.getLocation(findWhiteSpaceStart(this.scanner.source, this.scanner.source.length - 1))\n                    : this.locationMap.getLocation(this.scanner.tokenStart);\n\n            throw new SyntaxError(\n                message || 'Unexpected input',\n                this.scanner.source,\n                location.offset,\n                location.line,\n                location.column\n            );\n        }\n    };\n\n    config = processConfig(config || {});\n    for (var key in config) {\n        parser[key] = config[key];\n    }\n\n    return function(source, options) {\n        options = options || {};\n\n        var context = options.context || 'default';\n        var onComment = options.onComment;\n        var ast;\n\n        tokenize(source, parser.scanner);\n        parser.locationMap.setSource(\n            source,\n            options.offset,\n            options.line,\n            options.column\n        );\n\n        parser.filename = options.filename || '<unknown>';\n        parser.needPositions = Boolean(options.positions);\n        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop;\n        parser.onParseErrorThrow = false;\n        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;\n        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;\n        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;\n        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;\n\n        if (!parser.context.hasOwnProperty(context)) {\n            throw new Error('Unknown context `' + context + '`');\n        }\n\n        if (typeof onComment === 'function') {\n            parser.scanner.forEachToken((type, start, end) => {\n                if (type === COMMENT) {\n                    const loc = parser.getLocation(start, end);\n                    const value = cmpStr(source, end - 2, end, '*/')\n                        ? source.slice(start + 2, end - 2)\n                        : source.slice(start + 2, end);\n\n                    onComment(value, loc);\n                }\n            });\n        }\n\n        ast = parser.context[context].call(parser, options);\n\n        if (!parser.scanner.eof) {\n            parser.error();\n        }\n\n        return ast;\n    };\n};\n"]},"metadata":{},"sourceType":"script"}