{"ast":null,"code":"import NodeType from './nodes/type';\n\nfunction isTag(node) {\n  return node && node.nodeType === NodeType.ELEMENT_NODE;\n}\n\nfunction getAttributeValue(elem, name) {\n  return isTag(elem) ? elem.getAttribute(name) : undefined;\n}\n\nfunction getName(elem) {\n  return (elem && elem.rawTagName || '').toLowerCase();\n}\n\nfunction getChildren(node) {\n  return node && node.childNodes;\n}\n\nfunction getParent(node) {\n  return node ? node.parentNode : null;\n}\n\nfunction getText(node) {\n  return node.text;\n}\n\nfunction removeSubsets(nodes) {\n  let idx = nodes.length;\n  let node;\n  let ancestor;\n  let replace; // Check if each node (or one of its ancestors) is already contained in the\n  // array.\n\n  while (--idx > -1) {\n    node = ancestor = nodes[idx]; // Temporarily remove the node under consideration\n\n    nodes[idx] = null;\n    replace = true;\n\n    while (ancestor) {\n      if (nodes.indexOf(ancestor) > -1) {\n        replace = false;\n        nodes.splice(idx, 1);\n        break;\n      }\n\n      ancestor = getParent(ancestor);\n    } // If the node has been found to be unique, re-insert it.\n\n\n    if (replace) {\n      nodes[idx] = node;\n    }\n  }\n\n  return nodes;\n}\n\nfunction existsOne(test, elems) {\n  return elems.some(elem => {\n    return isTag(elem) ? test(elem) || existsOne(test, getChildren(elem)) : false;\n  });\n}\n\nfunction getSiblings(node) {\n  const parent = getParent(node);\n  return parent && getChildren(parent);\n}\n\nfunction hasAttrib(elem, name) {\n  return getAttributeValue(elem, name) !== undefined;\n}\n\nfunction findOne(test, elems) {\n  let elem = null;\n\n  for (let i = 0, l = elems.length; i < l && !elem; i++) {\n    const el = elems[i];\n\n    if (test(el)) {\n      elem = el;\n    } else {\n      const childs = getChildren(el);\n\n      if (childs && childs.length > 0) {\n        elem = findOne(test, childs);\n      }\n    }\n  }\n\n  return elem;\n}\n\nfunction findAll(test, nodes) {\n  let result = [];\n\n  for (let i = 0, j = nodes.length; i < j; i++) {\n    if (!isTag(nodes[i])) continue;\n    if (test(nodes[i])) result.push(nodes[i]);\n    const childs = getChildren(nodes[i]);\n    if (childs) result = result.concat(findAll(test, childs));\n  }\n\n  return result;\n}\n\nexport default {\n  isTag,\n  getAttributeValue,\n  getName,\n  getChildren,\n  getParent,\n  getText,\n  removeSubsets,\n  existsOne,\n  getSiblings,\n  hasAttrib,\n  findOne,\n  findAll\n};","map":{"version":3,"sources":["/Users/macbook/Documents/GitHub/React 3/billing-app/node_modules/node-html-parser/dist/esm/matcher.js"],"names":["NodeType","isTag","node","nodeType","ELEMENT_NODE","getAttributeValue","elem","name","getAttribute","undefined","getName","rawTagName","toLowerCase","getChildren","childNodes","getParent","parentNode","getText","text","removeSubsets","nodes","idx","length","ancestor","replace","indexOf","splice","existsOne","test","elems","some","getSiblings","parent","hasAttrib","findOne","i","l","el","childs","findAll","result","j","push","concat"],"mappings":"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","sourcesContent":["import NodeType from './nodes/type';\nfunction isTag(node) {\n    return node && node.nodeType === NodeType.ELEMENT_NODE;\n}\nfunction getAttributeValue(elem, name) {\n    return isTag(elem) ? elem.getAttribute(name) : undefined;\n}\nfunction getName(elem) {\n    return ((elem && elem.rawTagName) || '').toLowerCase();\n}\nfunction getChildren(node) {\n    return node && node.childNodes;\n}\nfunction getParent(node) {\n    return node ? node.parentNode : null;\n}\nfunction getText(node) {\n    return node.text;\n}\nfunction removeSubsets(nodes) {\n    let idx = nodes.length;\n    let node;\n    let ancestor;\n    let replace;\n    // Check if each node (or one of its ancestors) is already contained in the\n    // array.\n    while (--idx > -1) {\n        node = ancestor = nodes[idx];\n        // Temporarily remove the node under consideration\n        nodes[idx] = null;\n        replace = true;\n        while (ancestor) {\n            if (nodes.indexOf(ancestor) > -1) {\n                replace = false;\n                nodes.splice(idx, 1);\n                break;\n            }\n            ancestor = getParent(ancestor);\n        }\n        // If the node has been found to be unique, re-insert it.\n        if (replace) {\n            nodes[idx] = node;\n        }\n    }\n    return nodes;\n}\nfunction existsOne(test, elems) {\n    return elems.some((elem) => {\n        return isTag(elem) ? test(elem) || existsOne(test, getChildren(elem)) : false;\n    });\n}\nfunction getSiblings(node) {\n    const parent = getParent(node);\n    return parent && getChildren(parent);\n}\nfunction hasAttrib(elem, name) {\n    return getAttributeValue(elem, name) !== undefined;\n}\nfunction findOne(test, elems) {\n    let elem = null;\n    for (let i = 0, l = elems.length; i < l && !elem; i++) {\n        const el = elems[i];\n        if (test(el)) {\n            elem = el;\n        }\n        else {\n            const childs = getChildren(el);\n            if (childs && childs.length > 0) {\n                elem = findOne(test, childs);\n            }\n        }\n    }\n    return elem;\n}\nfunction findAll(test, nodes) {\n    let result = [];\n    for (let i = 0, j = nodes.length; i < j; i++) {\n        if (!isTag(nodes[i]))\n            continue;\n        if (test(nodes[i]))\n            result.push(nodes[i]);\n        const childs = getChildren(nodes[i]);\n        if (childs)\n            result = result.concat(findAll(test, childs));\n    }\n    return result;\n}\nexport default {\n    isTag,\n    getAttributeValue,\n    getName,\n    getChildren,\n    getParent,\n    getText,\n    removeSubsets,\n    existsOne,\n    getSiblings,\n    hasAttrib,\n    findOne,\n    findAll\n};\n"]},"metadata":{},"sourceType":"module"}