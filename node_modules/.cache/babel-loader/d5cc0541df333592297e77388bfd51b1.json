{"ast":null,"code":"function getTrace(node) {\n  function shouldPutToTrace(syntax) {\n    if (syntax === null) {\n      return false;\n    }\n\n    return syntax.type === 'Type' || syntax.type === 'Property' || syntax.type === 'Keyword';\n  }\n\n  function hasMatch(matchNode) {\n    if (Array.isArray(matchNode.match)) {\n      // use for-loop for better perfomance\n      for (var i = 0; i < matchNode.match.length; i++) {\n        if (hasMatch(matchNode.match[i])) {\n          if (shouldPutToTrace(matchNode.syntax)) {\n            result.unshift(matchNode.syntax);\n          }\n\n          return true;\n        }\n      }\n    } else if (matchNode.node === node) {\n      result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];\n      return true;\n    }\n\n    return false;\n  }\n\n  var result = null;\n\n  if (this.matched !== null) {\n    hasMatch(this.matched);\n  }\n\n  return result;\n}\n\nfunction testNode(match, node, fn) {\n  var trace = getTrace.call(match, node);\n\n  if (trace === null) {\n    return false;\n  }\n\n  return trace.some(fn);\n}\n\nfunction isType(node, type) {\n  return testNode(this, node, function (matchNode) {\n    return matchNode.type === 'Type' && matchNode.name === type;\n  });\n}\n\nfunction isProperty(node, property) {\n  return testNode(this, node, function (matchNode) {\n    return matchNode.type === 'Property' && matchNode.name === property;\n  });\n}\n\nfunction isKeyword(node) {\n  return testNode(this, node, function (matchNode) {\n    return matchNode.type === 'Keyword';\n  });\n}\n\nmodule.exports = {\n  getTrace: getTrace,\n  isType: isType,\n  isProperty: isProperty,\n  isKeyword: isKeyword\n};","map":{"version":3,"sources":["/Users/macbook/Documents/GitHub/React 3/billing-app/node_modules/react-pdf-html/node_modules/css-tree/lib/lexer/trace.js"],"names":["getTrace","node","shouldPutToTrace","syntax","type","hasMatch","matchNode","Array","isArray","match","i","length","result","unshift","matched","testNode","fn","trace","call","some","isType","name","isProperty","property","isKeyword","module","exports"],"mappings":"AAAA,SAASA,QAAT,CAAkBC,IAAlB,EAAwB;AACpB,WAASC,gBAAT,CAA0BC,MAA1B,EAAkC;AAC9B,QAAIA,MAAM,KAAK,IAAf,EAAqB;AACjB,aAAO,KAAP;AACH;;AAED,WACIA,MAAM,CAACC,IAAP,KAAgB,MAAhB,IACAD,MAAM,CAACC,IAAP,KAAgB,UADhB,IAEAD,MAAM,CAACC,IAAP,KAAgB,SAHpB;AAKH;;AAED,WAASC,QAAT,CAAkBC,SAAlB,EAA6B;AACzB,QAAIC,KAAK,CAACC,OAAN,CAAcF,SAAS,CAACG,KAAxB,CAAJ,EAAoC;AAChC;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,SAAS,CAACG,KAAV,CAAgBE,MAApC,EAA4CD,CAAC,EAA7C,EAAiD;AAC7C,YAAIL,QAAQ,CAACC,SAAS,CAACG,KAAV,CAAgBC,CAAhB,CAAD,CAAZ,EAAkC;AAC9B,cAAIR,gBAAgB,CAACI,SAAS,CAACH,MAAX,CAApB,EAAwC;AACpCS,YAAAA,MAAM,CAACC,OAAP,CAAeP,SAAS,CAACH,MAAzB;AACH;;AAED,iBAAO,IAAP;AACH;AACJ;AACJ,KAXD,MAWO,IAAIG,SAAS,CAACL,IAAV,KAAmBA,IAAvB,EAA6B;AAChCW,MAAAA,MAAM,GAAGV,gBAAgB,CAACI,SAAS,CAACH,MAAX,CAAhB,GACH,CAACG,SAAS,CAACH,MAAX,CADG,GAEH,EAFN;AAIA,aAAO,IAAP;AACH;;AAED,WAAO,KAAP;AACH;;AAED,MAAIS,MAAM,GAAG,IAAb;;AAEA,MAAI,KAAKE,OAAL,KAAiB,IAArB,EAA2B;AACvBT,IAAAA,QAAQ,CAAC,KAAKS,OAAN,CAAR;AACH;;AAED,SAAOF,MAAP;AACH;;AAED,SAASG,QAAT,CAAkBN,KAAlB,EAAyBR,IAAzB,EAA+Be,EAA/B,EAAmC;AAC/B,MAAIC,KAAK,GAAGjB,QAAQ,CAACkB,IAAT,CAAcT,KAAd,EAAqBR,IAArB,CAAZ;;AAEA,MAAIgB,KAAK,KAAK,IAAd,EAAoB;AAChB,WAAO,KAAP;AACH;;AAED,SAAOA,KAAK,CAACE,IAAN,CAAWH,EAAX,CAAP;AACH;;AAED,SAASI,MAAT,CAAgBnB,IAAhB,EAAsBG,IAAtB,EAA4B;AACxB,SAAOW,QAAQ,CAAC,IAAD,EAAOd,IAAP,EAAa,UAASK,SAAT,EAAoB;AAC5C,WAAOA,SAAS,CAACF,IAAV,KAAmB,MAAnB,IAA6BE,SAAS,CAACe,IAAV,KAAmBjB,IAAvD;AACH,GAFc,CAAf;AAGH;;AAED,SAASkB,UAAT,CAAoBrB,IAApB,EAA0BsB,QAA1B,EAAoC;AAChC,SAAOR,QAAQ,CAAC,IAAD,EAAOd,IAAP,EAAa,UAASK,SAAT,EAAoB;AAC5C,WAAOA,SAAS,CAACF,IAAV,KAAmB,UAAnB,IAAiCE,SAAS,CAACe,IAAV,KAAmBE,QAA3D;AACH,GAFc,CAAf;AAGH;;AAED,SAASC,SAAT,CAAmBvB,IAAnB,EAAyB;AACrB,SAAOc,QAAQ,CAAC,IAAD,EAAOd,IAAP,EAAa,UAASK,SAAT,EAAoB;AAC5C,WAAOA,SAAS,CAACF,IAAV,KAAmB,SAA1B;AACH,GAFc,CAAf;AAGH;;AAEDqB,MAAM,CAACC,OAAP,GAAiB;AACb1B,EAAAA,QAAQ,EAAEA,QADG;AAEboB,EAAAA,MAAM,EAAEA,MAFK;AAGbE,EAAAA,UAAU,EAAEA,UAHC;AAIbE,EAAAA,SAAS,EAAEA;AAJE,CAAjB","sourcesContent":["function getTrace(node) {\n    function shouldPutToTrace(syntax) {\n        if (syntax === null) {\n            return false;\n        }\n\n        return (\n            syntax.type === 'Type' ||\n            syntax.type === 'Property' ||\n            syntax.type === 'Keyword'\n        );\n    }\n\n    function hasMatch(matchNode) {\n        if (Array.isArray(matchNode.match)) {\n            // use for-loop for better perfomance\n            for (var i = 0; i < matchNode.match.length; i++) {\n                if (hasMatch(matchNode.match[i])) {\n                    if (shouldPutToTrace(matchNode.syntax)) {\n                        result.unshift(matchNode.syntax);\n                    }\n\n                    return true;\n                }\n            }\n        } else if (matchNode.node === node) {\n            result = shouldPutToTrace(matchNode.syntax)\n                ? [matchNode.syntax]\n                : [];\n\n            return true;\n        }\n\n        return false;\n    }\n\n    var result = null;\n\n    if (this.matched !== null) {\n        hasMatch(this.matched);\n    }\n\n    return result;\n}\n\nfunction testNode(match, node, fn) {\n    var trace = getTrace.call(match, node);\n\n    if (trace === null) {\n        return false;\n    }\n\n    return trace.some(fn);\n}\n\nfunction isType(node, type) {\n    return testNode(this, node, function(matchNode) {\n        return matchNode.type === 'Type' && matchNode.name === type;\n    });\n}\n\nfunction isProperty(node, property) {\n    return testNode(this, node, function(matchNode) {\n        return matchNode.type === 'Property' && matchNode.name === property;\n    });\n}\n\nfunction isKeyword(node) {\n    return testNode(this, node, function(matchNode) {\n        return matchNode.type === 'Keyword';\n    });\n}\n\nmodule.exports = {\n    getTrace: getTrace,\n    isType: isType,\n    isProperty: isProperty,\n    isKeyword: isKeyword\n};\n"]},"metadata":{},"sourceType":"script"}