{"ast":null,"code":"const hasOwnProperty = Object.prototype.hasOwnProperty;\nconst shape = {\n  generic: true,\n  types: appendOrAssign,\n  atrules: {\n    prelude: appendOrAssignOrNull,\n    descriptors: appendOrAssignOrNull\n  },\n  properties: appendOrAssign,\n  parseContext: assign,\n  scope: deepAssign,\n  atrule: ['parse'],\n  pseudo: ['parse'],\n  node: ['name', 'structure', 'parse', 'generate', 'walkContext']\n};\n\nfunction isObject(value) {\n  return value && value.constructor === Object;\n}\n\nfunction copy(value) {\n  return isObject(value) ? Object.assign({}, value) : value;\n}\n\nfunction assign(dest, src) {\n  return Object.assign(dest, src);\n}\n\nfunction deepAssign(dest, src) {\n  for (const key in src) {\n    if (hasOwnProperty.call(src, key)) {\n      if (isObject(dest[key])) {\n        deepAssign(dest[key], copy(src[key]));\n      } else {\n        dest[key] = copy(src[key]);\n      }\n    }\n  }\n\n  return dest;\n}\n\nfunction append(a, b) {\n  if (typeof b === 'string' && /^\\s*\\|/.test(b)) {\n    return typeof a === 'string' ? a + b : b.replace(/^\\s*\\|\\s*/, '');\n  }\n\n  return b || null;\n}\n\nfunction appendOrAssign(a, b) {\n  if (typeof b === 'string') {\n    return append(a, b);\n  }\n\n  const result = Object.assign({}, a);\n\n  for (let key in b) {\n    if (hasOwnProperty.call(b, key)) {\n      result[key] = append(hasOwnProperty.call(a, key) ? a[key] : undefined, b[key]);\n    }\n  }\n\n  return result;\n}\n\nfunction appendOrAssignOrNull(a, b) {\n  const result = appendOrAssign(a, b);\n  return !isObject(result) || Object.keys(result).length ? result : null;\n}\n\nfunction mix(dest, src, shape) {\n  for (const key in shape) {\n    if (hasOwnProperty.call(shape, key) === false) {\n      continue;\n    }\n\n    if (shape[key] === true) {\n      if (key in src) {\n        if (hasOwnProperty.call(src, key)) {\n          dest[key] = copy(src[key]);\n        }\n      }\n    } else if (shape[key]) {\n      if (typeof shape[key] === 'function') {\n        const fn = shape[key];\n        dest[key] = fn({}, dest[key]);\n        dest[key] = fn(dest[key] || {}, src[key]);\n      } else if (isObject(shape[key])) {\n        const result = {};\n\n        for (let name in dest[key]) {\n          result[name] = mix({}, dest[key][name], shape[key]);\n        }\n\n        for (let name in src[key]) {\n          result[name] = mix(result[name] || {}, src[key][name], shape[key]);\n        }\n\n        dest[key] = result;\n      } else if (Array.isArray(shape[key])) {\n        const res = {};\n        const innerShape = shape[key].reduce(function (s, k) {\n          s[k] = true;\n          return s;\n        }, {});\n\n        for (const [name, value] of Object.entries(dest[key] || {})) {\n          res[name] = {};\n\n          if (value) {\n            mix(res[name], value, innerShape);\n          }\n        }\n\n        for (const name in src[key]) {\n          if (hasOwnProperty.call(src[key], name)) {\n            if (!res[name]) {\n              res[name] = {};\n            }\n\n            if (src[key] && src[key][name]) {\n              mix(res[name], src[key][name], innerShape);\n            }\n          }\n        }\n\n        dest[key] = res;\n      }\n    }\n  }\n\n  return dest;\n}\n\nmodule.exports = (dest, src) => mix(dest, src, shape);","map":{"version":3,"sources":["/Users/macbook/Documents/GitHub/React 3/billing-app/node_modules/react-pdf-html/node_modules/css-tree/lib/syntax/config/mix.js"],"names":["hasOwnProperty","Object","prototype","shape","generic","types","appendOrAssign","atrules","prelude","appendOrAssignOrNull","descriptors","properties","parseContext","assign","scope","deepAssign","atrule","pseudo","node","isObject","value","constructor","copy","dest","src","key","call","append","a","b","test","replace","result","undefined","keys","length","mix","fn","name","Array","isArray","res","innerShape","reduce","s","k","entries","module","exports"],"mappings":"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","sourcesContent":["const hasOwnProperty = Object.prototype.hasOwnProperty;\nconst shape = {\n    generic: true,\n    types: appendOrAssign,\n    atrules: {\n        prelude: appendOrAssignOrNull,\n        descriptors: appendOrAssignOrNull\n    },\n    properties: appendOrAssign,\n    parseContext: assign,\n    scope: deepAssign,\n    atrule: ['parse'],\n    pseudo: ['parse'],\n    node: ['name', 'structure', 'parse', 'generate', 'walkContext']\n};\n\nfunction isObject(value) {\n    return value && value.constructor === Object;\n}\n\nfunction copy(value) {\n    return isObject(value)\n        ? Object.assign({}, value)\n        : value;\n}\n\nfunction assign(dest, src) {\n    return Object.assign(dest, src);\n}\n\nfunction deepAssign(dest, src) {\n    for (const key in src) {\n        if (hasOwnProperty.call(src, key)) {\n            if (isObject(dest[key])) {\n                deepAssign(dest[key], copy(src[key]));\n            } else {\n                dest[key] = copy(src[key]);\n            }\n        }\n    }\n\n    return dest;\n}\n\nfunction append(a, b) {\n    if (typeof b === 'string' && /^\\s*\\|/.test(b)) {\n        return typeof a === 'string'\n            ? a + b\n            : b.replace(/^\\s*\\|\\s*/, '');\n    }\n\n    return b || null;\n}\n\nfunction appendOrAssign(a, b) {\n    if (typeof b === 'string') {\n        return append(a, b);\n    }\n\n    const result = Object.assign({}, a);\n    for (let key in b) {\n        if (hasOwnProperty.call(b, key)) {\n            result[key] = append(hasOwnProperty.call(a, key) ? a[key] : undefined, b[key]);\n        }\n    }\n\n    return result;\n}\n\nfunction appendOrAssignOrNull(a, b) {\n    const result = appendOrAssign(a, b);\n\n    return !isObject(result) || Object.keys(result).length\n        ? result\n        : null;\n}\n\nfunction mix(dest, src, shape) {\n    for (const key in shape) {\n        if (hasOwnProperty.call(shape, key) === false) {\n            continue;\n        }\n\n        if (shape[key] === true) {\n            if (key in src) {\n                if (hasOwnProperty.call(src, key)) {\n                    dest[key] = copy(src[key]);\n                }\n            }\n        } else if (shape[key]) {\n            if (typeof shape[key] === 'function') {\n                const fn = shape[key];\n                dest[key] = fn({}, dest[key]);\n                dest[key] = fn(dest[key] || {}, src[key]);\n            } else if (isObject(shape[key])) {\n                const result = {};\n\n                for (let name in dest[key]) {\n                    result[name] = mix({}, dest[key][name], shape[key]);\n                }\n\n                for (let name in src[key]) {\n                    result[name] = mix(result[name] || {}, src[key][name], shape[key]);\n                }\n\n                dest[key] = result;\n            } else if (Array.isArray(shape[key])) {\n                const res = {};\n                const innerShape = shape[key].reduce(function(s, k) {\n                    s[k] = true;\n                    return s;\n                }, {});\n\n                for (const [name, value] of Object.entries(dest[key] || {})) {\n                    res[name] = {};\n                    if (value) {\n                        mix(res[name], value, innerShape);\n                    }\n                }\n\n                for (const name in src[key]) {\n                    if (hasOwnProperty.call(src[key], name)) {\n                        if (!res[name]) {\n                            res[name] = {};\n                        }\n\n                        if (src[key] && src[key][name]) {\n                            mix(res[name], src[key][name], innerShape);\n                        }\n                    }\n                }\n\n                dest[key] = res;\n            }\n        }\n    }\n    return dest;\n}\n\nmodule.exports = (dest, src) => mix(dest, src, shape);\n"]},"metadata":{},"sourceType":"script"}