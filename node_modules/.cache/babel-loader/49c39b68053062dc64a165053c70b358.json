{"ast":null,"code":"import NodeType from './type';\nimport Node from './node';\n/**\n * TextNode to contain a text element in DOM tree.\n * @param {string} value [description]\n */\n\nexport default class TextNode extends Node {\n  constructor(rawText, parentNode) {\n    super(parentNode);\n    this.rawText = rawText;\n    /**\n     * Node Type declaration.\n     * @type {Number}\n     */\n\n    this.nodeType = NodeType.TEXT_NODE;\n  }\n  /**\n   * Returns text with all whitespace trimmed except single leading/trailing non-breaking space\n   */\n\n\n  get trimmedText() {\n    if (this._trimmedText !== undefined) return this._trimmedText;\n    const text = this.rawText;\n    let i = 0;\n    let startPos;\n    let endPos;\n\n    while (i >= 0 && i < text.length) {\n      if (/\\S/.test(text[i])) {\n        if (startPos === undefined) {\n          startPos = i;\n          i = text.length;\n        } else {\n          endPos = i;\n          i = void 0;\n        }\n      }\n\n      if (startPos === undefined) i++;else i--;\n    }\n\n    if (startPos === undefined) startPos = 0;\n    if (endPos === undefined) endPos = text.length - 1;\n    const hasLeadingSpace = startPos > 0 && /[^\\S\\r\\n]/.test(text[startPos - 1]);\n    const hasTrailingSpace = endPos < text.length - 1 && /[^\\S\\r\\n]/.test(text[endPos + 1]);\n    this._trimmedText = (hasLeadingSpace ? ' ' : '') + text.slice(startPos, endPos + 1) + (hasTrailingSpace ? ' ' : '');\n    return this._trimmedText;\n  }\n  /**\n   * Get unescaped text value of current node and its children.\n   * @return {string} text content\n   */\n\n\n  get text() {\n    return this.rawText;\n  }\n  /**\n   * Detect if the node contains only white space.\n   * @return {bool}\n   */\n\n\n  get isWhitespace() {\n    return /^(\\s|&nbsp;)*$/.test(this.rawText);\n  }\n\n  toString() {\n    return this.text;\n  }\n\n}","map":{"version":3,"sources":["/Users/macbook/Documents/GitHub/React 3/billing-app/node_modules/node-html-parser/dist/esm/nodes/text.js"],"names":["NodeType","Node","TextNode","constructor","rawText","parentNode","nodeType","TEXT_NODE","trimmedText","_trimmedText","undefined","text","i","startPos","endPos","length","test","hasLeadingSpace","hasTrailingSpace","slice","isWhitespace","toString"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,QAArB;AACA,OAAOC,IAAP,MAAiB,QAAjB;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,QAAN,SAAuBD,IAAvB,CAA4B;AACvCE,EAAAA,WAAW,CAACC,OAAD,EAAUC,UAAV,EAAsB;AAC7B,UAAMA,UAAN;AACA,SAAKD,OAAL,GAAeA,OAAf;AACA;AACR;AACA;AACA;;AACQ,SAAKE,QAAL,GAAgBN,QAAQ,CAACO,SAAzB;AACH;AACD;AACJ;AACA;;;AACmB,MAAXC,WAAW,GAAG;AACd,QAAI,KAAKC,YAAL,KAAsBC,SAA1B,EACI,OAAO,KAAKD,YAAZ;AACJ,UAAME,IAAI,GAAG,KAAKP,OAAlB;AACA,QAAIQ,CAAC,GAAG,CAAR;AACA,QAAIC,QAAJ;AACA,QAAIC,MAAJ;;AACA,WAAOF,CAAC,IAAI,CAAL,IAAUA,CAAC,GAAGD,IAAI,CAACI,MAA1B,EAAkC;AAC9B,UAAI,KAAKC,IAAL,CAAUL,IAAI,CAACC,CAAD,CAAd,CAAJ,EAAwB;AACpB,YAAIC,QAAQ,KAAKH,SAAjB,EAA4B;AACxBG,UAAAA,QAAQ,GAAGD,CAAX;AACAA,UAAAA,CAAC,GAAGD,IAAI,CAACI,MAAT;AACH,SAHD,MAIK;AACDD,UAAAA,MAAM,GAAGF,CAAT;AACAA,UAAAA,CAAC,GAAG,KAAK,CAAT;AACH;AACJ;;AACD,UAAIC,QAAQ,KAAKH,SAAjB,EACIE,CAAC,GADL,KAGIA,CAAC;AACR;;AACD,QAAIC,QAAQ,KAAKH,SAAjB,EACIG,QAAQ,GAAG,CAAX;AACJ,QAAIC,MAAM,KAAKJ,SAAf,EACII,MAAM,GAAGH,IAAI,CAACI,MAAL,GAAc,CAAvB;AACJ,UAAME,eAAe,GAAGJ,QAAQ,GAAG,CAAX,IAAgB,YAAYG,IAAZ,CAAiBL,IAAI,CAACE,QAAQ,GAAG,CAAZ,CAArB,CAAxC;AACA,UAAMK,gBAAgB,GAAGJ,MAAM,GAAIH,IAAI,CAACI,MAAL,GAAc,CAAxB,IAA8B,YAAYC,IAAZ,CAAiBL,IAAI,CAACG,MAAM,GAAG,CAAV,CAArB,CAAvD;AACA,SAAKL,YAAL,GAAoB,CAACQ,eAAe,GAAG,GAAH,GAAS,EAAzB,IAA+BN,IAAI,CAACQ,KAAL,CAAWN,QAAX,EAAqBC,MAAM,GAAG,CAA9B,CAA/B,IAAmEI,gBAAgB,GAAG,GAAH,GAAS,EAA5F,CAApB;AACA,WAAO,KAAKT,YAAZ;AACH;AACD;AACJ;AACA;AACA;;;AACY,MAAJE,IAAI,GAAG;AACP,WAAO,KAAKP,OAAZ;AACH;AACD;AACJ;AACA;AACA;;;AACoB,MAAZgB,YAAY,GAAG;AACf,WAAO,iBAAiBJ,IAAjB,CAAsB,KAAKZ,OAA3B,CAAP;AACH;;AACDiB,EAAAA,QAAQ,GAAG;AACP,WAAO,KAAKV,IAAZ;AACH;;AA7DsC","sourcesContent":["import NodeType from './type';\nimport Node from './node';\n/**\n * TextNode to contain a text element in DOM tree.\n * @param {string} value [description]\n */\nexport default class TextNode extends Node {\n    constructor(rawText, parentNode) {\n        super(parentNode);\n        this.rawText = rawText;\n        /**\n         * Node Type declaration.\n         * @type {Number}\n         */\n        this.nodeType = NodeType.TEXT_NODE;\n    }\n    /**\n     * Returns text with all whitespace trimmed except single leading/trailing non-breaking space\n     */\n    get trimmedText() {\n        if (this._trimmedText !== undefined)\n            return this._trimmedText;\n        const text = this.rawText;\n        let i = 0;\n        let startPos;\n        let endPos;\n        while (i >= 0 && i < text.length) {\n            if (/\\S/.test(text[i])) {\n                if (startPos === undefined) {\n                    startPos = i;\n                    i = text.length;\n                }\n                else {\n                    endPos = i;\n                    i = void 0;\n                }\n            }\n            if (startPos === undefined)\n                i++;\n            else\n                i--;\n        }\n        if (startPos === undefined)\n            startPos = 0;\n        if (endPos === undefined)\n            endPos = text.length - 1;\n        const hasLeadingSpace = startPos > 0 && /[^\\S\\r\\n]/.test(text[startPos - 1]);\n        const hasTrailingSpace = endPos < (text.length - 1) && /[^\\S\\r\\n]/.test(text[endPos + 1]);\n        this._trimmedText = (hasLeadingSpace ? ' ' : '') + text.slice(startPos, endPos + 1) + (hasTrailingSpace ? ' ' : '');\n        return this._trimmedText;\n    }\n    /**\n     * Get unescaped text value of current node and its children.\n     * @return {string} text content\n     */\n    get text() {\n        return this.rawText;\n    }\n    /**\n     * Detect if the node contains only white space.\n     * @return {bool}\n     */\n    get isWhitespace() {\n        return /^(\\s|&nbsp;)*$/.test(this.rawText);\n    }\n    toString() {\n        return this.text;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}