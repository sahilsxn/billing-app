{"ast":null,"code":"var constants = require('../tokenizer/const');\n\nvar TYPE = constants.TYPE;\nvar NAME = constants.NAME;\n\nvar utils = require('../tokenizer/utils');\n\nvar cmpStr = utils.cmpStr;\nvar EOF = TYPE.EOF;\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\nvar OFFSET_MASK = 0x00FFFFFF;\nvar TYPE_SHIFT = 24;\n\nvar TokenStream = function () {\n  this.offsetAndType = null;\n  this.balance = null;\n  this.reset();\n};\n\nTokenStream.prototype = {\n  reset: function () {\n    this.eof = false;\n    this.tokenIndex = -1;\n    this.tokenType = 0;\n    this.tokenStart = this.firstCharOffset;\n    this.tokenEnd = this.firstCharOffset;\n  },\n  lookupType: function (offset) {\n    offset += this.tokenIndex;\n\n    if (offset < this.tokenCount) {\n      return this.offsetAndType[offset] >> TYPE_SHIFT;\n    }\n\n    return EOF;\n  },\n  lookupOffset: function (offset) {\n    offset += this.tokenIndex;\n\n    if (offset < this.tokenCount) {\n      return this.offsetAndType[offset - 1] & OFFSET_MASK;\n    }\n\n    return this.source.length;\n  },\n  lookupValue: function (offset, referenceStr) {\n    offset += this.tokenIndex;\n\n    if (offset < this.tokenCount) {\n      return cmpStr(this.source, this.offsetAndType[offset - 1] & OFFSET_MASK, this.offsetAndType[offset] & OFFSET_MASK, referenceStr);\n    }\n\n    return false;\n  },\n  getTokenStart: function (tokenIndex) {\n    if (tokenIndex === this.tokenIndex) {\n      return this.tokenStart;\n    }\n\n    if (tokenIndex > 0) {\n      return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;\n    }\n\n    return this.firstCharOffset;\n  },\n  // TODO: -> skipUntilBalanced\n  getRawLength: function (startToken, mode) {\n    var cursor = startToken;\n    var balanceEnd;\n    var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;\n    var type;\n\n    loop: for (; cursor < this.tokenCount; cursor++) {\n      balanceEnd = this.balance[cursor]; // stop scanning on balance edge that points to offset before start token\n\n      if (balanceEnd < startToken) {\n        break loop;\n      }\n\n      type = this.offsetAndType[cursor] >> TYPE_SHIFT; // check token is stop type\n\n      switch (mode(type, this.source, offset)) {\n        case 1:\n          break loop;\n\n        case 2:\n          cursor++;\n          break loop;\n\n        default:\n          // fast forward to the end of balanced block\n          if (this.balance[balanceEnd] === cursor) {\n            cursor = balanceEnd;\n          }\n\n          offset = this.offsetAndType[cursor] & OFFSET_MASK;\n      }\n    }\n\n    return cursor - this.tokenIndex;\n  },\n  isBalanceEdge: function (pos) {\n    return this.balance[this.tokenIndex] < pos;\n  },\n  isDelim: function (code, offset) {\n    if (offset) {\n      return this.lookupType(offset) === TYPE.Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code;\n    }\n\n    return this.tokenType === TYPE.Delim && this.source.charCodeAt(this.tokenStart) === code;\n  },\n  getTokenValue: function () {\n    return this.source.substring(this.tokenStart, this.tokenEnd);\n  },\n  getTokenLength: function () {\n    return this.tokenEnd - this.tokenStart;\n  },\n  substrToCursor: function (start) {\n    return this.source.substring(start, this.tokenStart);\n  },\n  skipWS: function () {\n    for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {\n      if (this.offsetAndType[i] >> TYPE_SHIFT !== WHITESPACE) {\n        break;\n      }\n    }\n\n    if (skipTokenCount > 0) {\n      this.skip(skipTokenCount);\n    }\n  },\n  skipSC: function () {\n    while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {\n      this.next();\n    }\n  },\n  skip: function (tokenCount) {\n    var next = this.tokenIndex + tokenCount;\n\n    if (next < this.tokenCount) {\n      this.tokenIndex = next;\n      this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;\n      next = this.offsetAndType[next];\n      this.tokenType = next >> TYPE_SHIFT;\n      this.tokenEnd = next & OFFSET_MASK;\n    } else {\n      this.tokenIndex = this.tokenCount;\n      this.next();\n    }\n  },\n  next: function () {\n    var next = this.tokenIndex + 1;\n\n    if (next < this.tokenCount) {\n      this.tokenIndex = next;\n      this.tokenStart = this.tokenEnd;\n      next = this.offsetAndType[next];\n      this.tokenType = next >> TYPE_SHIFT;\n      this.tokenEnd = next & OFFSET_MASK;\n    } else {\n      this.tokenIndex = this.tokenCount;\n      this.eof = true;\n      this.tokenType = EOF;\n      this.tokenStart = this.tokenEnd = this.source.length;\n    }\n  },\n\n  forEachToken(fn) {\n    for (var i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {\n      var start = offset;\n      var item = this.offsetAndType[i];\n      var end = item & OFFSET_MASK;\n      var type = item >> TYPE_SHIFT;\n      offset = end;\n      fn(type, start, end, i);\n    }\n  },\n\n  dump() {\n    var tokens = new Array(this.tokenCount);\n    this.forEachToken((type, start, end, index) => {\n      tokens[index] = {\n        idx: index,\n        type: NAME[type],\n        chunk: this.source.substring(start, end),\n        balance: this.balance[index]\n      };\n    });\n    return tokens;\n  }\n\n};\nmodule.exports = TokenStream;","map":{"version":3,"sources":["/Users/macbook/Documents/GitHub/React 3/billing-app/node_modules/react-pdf-html/node_modules/css-tree/lib/common/TokenStream.js"],"names":["constants","require","TYPE","NAME","utils","cmpStr","EOF","WHITESPACE","WhiteSpace","COMMENT","Comment","OFFSET_MASK","TYPE_SHIFT","TokenStream","offsetAndType","balance","reset","prototype","eof","tokenIndex","tokenType","tokenStart","firstCharOffset","tokenEnd","lookupType","offset","tokenCount","lookupOffset","source","length","lookupValue","referenceStr","getTokenStart","getRawLength","startToken","mode","cursor","balanceEnd","Math","max","type","loop","isBalanceEdge","pos","isDelim","code","Delim","charCodeAt","getTokenValue","substring","getTokenLength","substrToCursor","start","skipWS","i","skipTokenCount","skip","skipSC","next","forEachToken","fn","item","end","dump","tokens","Array","index","idx","chunk","module","exports"],"mappings":"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","sourcesContent":["var constants = require('../tokenizer/const');\nvar TYPE = constants.TYPE;\nvar NAME = constants.NAME;\n\nvar utils = require('../tokenizer/utils');\nvar cmpStr = utils.cmpStr;\n\nvar EOF = TYPE.EOF;\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\n\nvar OFFSET_MASK = 0x00FFFFFF;\nvar TYPE_SHIFT = 24;\n\nvar TokenStream = function() {\n    this.offsetAndType = null;\n    this.balance = null;\n\n    this.reset();\n};\n\nTokenStream.prototype = {\n    reset: function() {\n        this.eof = false;\n        this.tokenIndex = -1;\n        this.tokenType = 0;\n        this.tokenStart = this.firstCharOffset;\n        this.tokenEnd = this.firstCharOffset;\n    },\n\n    lookupType: function(offset) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return this.offsetAndType[offset] >> TYPE_SHIFT;\n        }\n\n        return EOF;\n    },\n    lookupOffset: function(offset) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return this.offsetAndType[offset - 1] & OFFSET_MASK;\n        }\n\n        return this.source.length;\n    },\n    lookupValue: function(offset, referenceStr) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return cmpStr(\n                this.source,\n                this.offsetAndType[offset - 1] & OFFSET_MASK,\n                this.offsetAndType[offset] & OFFSET_MASK,\n                referenceStr\n            );\n        }\n\n        return false;\n    },\n    getTokenStart: function(tokenIndex) {\n        if (tokenIndex === this.tokenIndex) {\n            return this.tokenStart;\n        }\n\n        if (tokenIndex > 0) {\n            return tokenIndex < this.tokenCount\n                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK\n                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;\n        }\n\n        return this.firstCharOffset;\n    },\n\n    // TODO: -> skipUntilBalanced\n    getRawLength: function(startToken, mode) {\n        var cursor = startToken;\n        var balanceEnd;\n        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;\n        var type;\n\n        loop:\n        for (; cursor < this.tokenCount; cursor++) {\n            balanceEnd = this.balance[cursor];\n\n            // stop scanning on balance edge that points to offset before start token\n            if (balanceEnd < startToken) {\n                break loop;\n            }\n\n            type = this.offsetAndType[cursor] >> TYPE_SHIFT;\n\n            // check token is stop type\n            switch (mode(type, this.source, offset)) {\n                case 1:\n                    break loop;\n\n                case 2:\n                    cursor++;\n                    break loop;\n\n                default:\n                    // fast forward to the end of balanced block\n                    if (this.balance[balanceEnd] === cursor) {\n                        cursor = balanceEnd;\n                    }\n\n                    offset = this.offsetAndType[cursor] & OFFSET_MASK;\n            }\n        }\n\n        return cursor - this.tokenIndex;\n    },\n    isBalanceEdge: function(pos) {\n        return this.balance[this.tokenIndex] < pos;\n    },\n    isDelim: function(code, offset) {\n        if (offset) {\n            return (\n                this.lookupType(offset) === TYPE.Delim &&\n                this.source.charCodeAt(this.lookupOffset(offset)) === code\n            );\n        }\n\n        return (\n            this.tokenType === TYPE.Delim &&\n            this.source.charCodeAt(this.tokenStart) === code\n        );\n    },\n\n    getTokenValue: function() {\n        return this.source.substring(this.tokenStart, this.tokenEnd);\n    },\n    getTokenLength: function() {\n        return this.tokenEnd - this.tokenStart;\n    },\n    substrToCursor: function(start) {\n        return this.source.substring(start, this.tokenStart);\n    },\n\n    skipWS: function() {\n        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {\n            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {\n                break;\n            }\n        }\n\n        if (skipTokenCount > 0) {\n            this.skip(skipTokenCount);\n        }\n    },\n    skipSC: function() {\n        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {\n            this.next();\n        }\n    },\n    skip: function(tokenCount) {\n        var next = this.tokenIndex + tokenCount;\n\n        if (next < this.tokenCount) {\n            this.tokenIndex = next;\n            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;\n            next = this.offsetAndType[next];\n            this.tokenType = next >> TYPE_SHIFT;\n            this.tokenEnd = next & OFFSET_MASK;\n        } else {\n            this.tokenIndex = this.tokenCount;\n            this.next();\n        }\n    },\n    next: function() {\n        var next = this.tokenIndex + 1;\n\n        if (next < this.tokenCount) {\n            this.tokenIndex = next;\n            this.tokenStart = this.tokenEnd;\n            next = this.offsetAndType[next];\n            this.tokenType = next >> TYPE_SHIFT;\n            this.tokenEnd = next & OFFSET_MASK;\n        } else {\n            this.tokenIndex = this.tokenCount;\n            this.eof = true;\n            this.tokenType = EOF;\n            this.tokenStart = this.tokenEnd = this.source.length;\n        }\n    },\n\n    forEachToken(fn) {\n        for (var i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {\n            var start = offset;\n            var item = this.offsetAndType[i];\n            var end = item & OFFSET_MASK;\n            var type = item >> TYPE_SHIFT;\n\n            offset = end;\n\n            fn(type, start, end, i);\n        }\n    },\n\n    dump() {\n        var tokens = new Array(this.tokenCount);\n\n        this.forEachToken((type, start, end, index) => {\n            tokens[index] = {\n                idx: index,\n                type: NAME[type],\n                chunk: this.source.substring(start, end),\n                balance: this.balance[index]\n            };\n        });\n\n        return tokens;\n    }\n};\n\nmodule.exports = TokenStream;\n"]},"metadata":{},"sourceType":"script"}