{"ast":null,"code":"const mdnAtrules = require('mdn-data/css/at-rules.json');\n\nconst mdnProperties = require('mdn-data/css/properties.json');\n\nconst mdnSyntaxes = require('mdn-data/css/syntaxes.json');\n\nconst patch = require('./patch.json');\n\nconst extendSyntax = /^\\s*\\|\\s*/;\n\nfunction preprocessAtrules(dict) {\n  const result = Object.create(null);\n\n  for (const atruleName in dict) {\n    const atrule = dict[atruleName];\n    let descriptors = null;\n\n    if (atrule.descriptors) {\n      descriptors = Object.create(null);\n\n      for (const descriptor in atrule.descriptors) {\n        descriptors[descriptor] = atrule.descriptors[descriptor].syntax;\n      }\n    }\n\n    result[atruleName.substr(1)] = {\n      prelude: atrule.syntax.trim().match(/^@\\S+\\s+([^;\\{]*)/)[1].trim() || null,\n      descriptors\n    };\n  }\n\n  return result;\n}\n\nfunction patchDictionary(dict, patchDict) {\n  const result = {}; // copy all syntaxes for an original dict\n\n  for (const key in dict) {\n    result[key] = dict[key].syntax || dict[key];\n  } // apply a patch\n\n\n  for (const key in patchDict) {\n    if (key in dict) {\n      if (patchDict[key].syntax) {\n        result[key] = extendSyntax.test(patchDict[key].syntax) ? result[key] + ' ' + patchDict[key].syntax.trim() : patchDict[key].syntax;\n      } else {\n        delete result[key];\n      }\n    } else {\n      if (patchDict[key].syntax) {\n        result[key] = patchDict[key].syntax.replace(extendSyntax, '');\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction unpackSyntaxes(dict) {\n  const result = {};\n\n  for (const key in dict) {\n    result[key] = dict[key].syntax;\n  }\n\n  return result;\n}\n\nfunction patchAtrules(dict, patchDict) {\n  const result = {}; // copy all syntaxes for an original dict\n\n  for (const key in dict) {\n    const patchDescriptors = patchDict[key] && patchDict[key].descriptors || null;\n    result[key] = {\n      prelude: key in patchDict && 'prelude' in patchDict[key] ? patchDict[key].prelude : dict[key].prelude || null,\n      descriptors: dict[key].descriptors ? patchDictionary(dict[key].descriptors, patchDescriptors || {}) : patchDescriptors && unpackSyntaxes(patchDescriptors)\n    };\n  } // apply a patch\n\n\n  for (const key in patchDict) {\n    if (!hasOwnProperty.call(dict, key)) {\n      result[key] = {\n        prelude: patchDict[key].prelude || null,\n        descriptors: patchDict[key].descriptors && unpackSyntaxes(patchDict[key].descriptors)\n      };\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  types: patchDictionary(mdnSyntaxes, patch.syntaxes),\n  atrules: patchAtrules(preprocessAtrules(mdnAtrules), patch.atrules),\n  properties: patchDictionary(mdnProperties, patch.properties)\n};","map":{"version":3,"sources":["/Users/macbook/Documents/GitHub/React 3/billing-app/node_modules/react-pdf-html/node_modules/css-tree/data/index.js"],"names":["mdnAtrules","require","mdnProperties","mdnSyntaxes","patch","extendSyntax","preprocessAtrules","dict","result","Object","create","atruleName","atrule","descriptors","descriptor","syntax","substr","prelude","trim","match","patchDictionary","patchDict","key","test","replace","unpackSyntaxes","patchAtrules","patchDescriptors","hasOwnProperty","call","module","exports","types","syntaxes","atrules","properties"],"mappings":"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","sourcesContent":["const mdnAtrules = require('mdn-data/css/at-rules.json');\nconst mdnProperties = require('mdn-data/css/properties.json');\nconst mdnSyntaxes = require('mdn-data/css/syntaxes.json');\nconst patch = require('./patch.json');\nconst extendSyntax = /^\\s*\\|\\s*/;\n\nfunction preprocessAtrules(dict) {\n    const result = Object.create(null);\n\n    for (const atruleName in dict) {\n        const atrule = dict[atruleName];\n        let descriptors = null;\n\n        if (atrule.descriptors) {\n            descriptors = Object.create(null);\n\n            for (const descriptor in atrule.descriptors) {\n                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;\n            }\n        }\n\n        result[atruleName.substr(1)] = {\n            prelude: atrule.syntax.trim().match(/^@\\S+\\s+([^;\\{]*)/)[1].trim() || null,\n            descriptors\n        };\n    }\n\n    return result;\n}\n\nfunction patchDictionary(dict, patchDict) {\n    const result = {};\n\n    // copy all syntaxes for an original dict\n    for (const key in dict) {\n        result[key] = dict[key].syntax || dict[key];\n    }\n\n    // apply a patch\n    for (const key in patchDict) {\n        if (key in dict) {\n            if (patchDict[key].syntax) {\n                result[key] = extendSyntax.test(patchDict[key].syntax)\n                    ? result[key] + ' ' + patchDict[key].syntax.trim()\n                    : patchDict[key].syntax;\n            } else {\n                delete result[key];\n            }\n        } else {\n            if (patchDict[key].syntax) {\n                result[key] = patchDict[key].syntax.replace(extendSyntax, '');\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction unpackSyntaxes(dict) {\n    const result = {};\n\n    for (const key in dict) {\n        result[key] = dict[key].syntax;\n    }\n\n    return result;\n}\n\nfunction patchAtrules(dict, patchDict) {\n    const result = {};\n\n    // copy all syntaxes for an original dict\n    for (const key in dict) {\n        const patchDescriptors = (patchDict[key] && patchDict[key].descriptors) || null;\n\n        result[key] = {\n            prelude: key in patchDict && 'prelude' in patchDict[key]\n                ? patchDict[key].prelude\n                : dict[key].prelude || null,\n            descriptors: dict[key].descriptors\n                ? patchDictionary(dict[key].descriptors, patchDescriptors || {})\n                : patchDescriptors && unpackSyntaxes(patchDescriptors)\n        };\n    }\n\n    // apply a patch\n    for (const key in patchDict) {\n        if (!hasOwnProperty.call(dict, key)) {\n            result[key] = {\n                prelude: patchDict[key].prelude || null,\n                descriptors: patchDict[key].descriptors && unpackSyntaxes(patchDict[key].descriptors)\n            };\n        }\n    }\n\n    return result;\n}\n\nmodule.exports = {\n    types: patchDictionary(mdnSyntaxes, patch.syntaxes),\n    atrules: patchAtrules(preprocessAtrules(mdnAtrules), patch.atrules),\n    properties: patchDictionary(mdnProperties, patch.properties)\n};\n"]},"metadata":{},"sourceType":"script"}