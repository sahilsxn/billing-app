{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convertNode = exports.convertElementStyle = exports.convertStylesheet = exports.convertRule = void 0;\n\nconst node_html_parser_1 = require(\"node-html-parser\");\n\nconst css_tree_1 = __importDefault(require(\"css-tree\"));\n\nconst supportedStyles_1 = __importDefault(require(\"./supportedStyles\"));\n\nconst camelize = require('camelize');\n\nconst convertRule = function (rule) {\n  let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'style';\n  const declarations = rule.children.filter(declaration => declaration.type === 'Declaration').toArray();\n  return declarations.map(entry => Object.assign(Object.assign({}, entry), {\n    property: camelize(entry.property)\n  })).reduce((style, _ref) => {\n    let {\n      property,\n      value\n    } = _ref;\n    const valueString = css_tree_1.default.generate(value);\n\n    if (property && value) {\n      if (!property || !supportedStyles_1.default.includes(property)) {\n        if (property === 'background' && /^#?[a-zA-Z0-9]+$/.test(valueString) || /^rgba?\\([0-9, ]+\\)$/i.test(valueString) || /^hsla?\\([0-9.%, ]+\\)$/i.test(valueString)) {\n          property = 'backgroundColor';\n        } else {\n          console.warn(`${source}: Found unsupported style \"${property}\"`, {\n            property,\n            value\n          });\n        }\n      }\n\n      style[property] = valueString;\n    }\n\n    return style;\n  }, {});\n};\n\nexports.convertRule = convertRule;\n\nconst convertStylesheet = stylesheet => {\n  const response = {};\n\n  try {\n    const parsed = css_tree_1.default.parse(stylesheet);\n    const rules = parsed.children.filter(rule => {\n      var _a;\n\n      return rule.type === 'Rule' && ((_a = rule.prelude) === null || _a === void 0 ? void 0 : _a.type) === 'SelectorList';\n    });\n    rules.forEach(rule => {\n      const style = (0, exports.convertRule)(rule.block);\n\n      if (rule.prelude.type !== 'SelectorList') {\n        return;\n      }\n\n      rule.prelude.children.forEach(selector => {\n        const selectorString = css_tree_1.default.generate(selector);\n        response[selectorString] = style;\n      });\n    });\n  } catch (e) {\n    console.error(`Error parsing stylesheet: \"${stylesheet}\"`, e);\n  }\n\n  return response;\n};\n\nexports.convertStylesheet = convertStylesheet;\n\nconst convertElementStyle = (styleAttr, tag) => {\n  try {\n    const parsed = css_tree_1.default.parse(`${tag} { ${styleAttr} }`);\n    const rules = parsed.children.filter(rule => {\n      var _a;\n\n      return rule.type === 'Rule' && ((_a = rule.prelude) === null || _a === void 0 ? void 0 : _a.type) === 'SelectorList';\n    });\n    const firstRule = rules.first();\n    return firstRule ? (0, exports.convertRule)(firstRule.block, tag) : undefined;\n  } catch (e) {\n    console.error(`Error parsing style attribute \"${styleAttr}\" for tag: ${tag}`, e);\n  }\n};\n\nexports.convertElementStyle = convertElementStyle;\n\nconst convertNode = node => {\n  if (node.nodeType === node_html_parser_1.NodeType.TEXT_NODE) {\n    return node.rawText;\n  }\n\n  if (node.nodeType === node_html_parser_1.NodeType.COMMENT_NODE) {\n    return '';\n  }\n\n  if (node.nodeType !== node_html_parser_1.NodeType.ELEMENT_NODE) {\n    throw new Error('Not sure what this is');\n  }\n\n  const html = node;\n  const content = html.childNodes.map(exports.convertNode);\n  const kindCounters = {};\n  content.forEach(child => {\n    if (typeof child !== 'string') {\n      child.indexOfType = child.tag in kindCounters ? kindCounters[child.tag] = kindCounters[child.tag] + 1 : kindCounters[child.tag] = 0;\n    }\n  });\n  let style;\n\n  if (html.attributes.style && html.attributes.style.trim()) {\n    style = (0, exports.convertElementStyle)(html.attributes.style, html.tagName);\n  }\n\n  return Object.assign(html, {\n    tag: (html.tagName || '').toLowerCase(),\n    style: style ? [style] : [],\n    content,\n    indexOfType: 0\n  });\n};\n\nexports.convertNode = convertNode;\n\nconst parseHtml = text => {\n  const html = (0, node_html_parser_1.parse)(text, {\n    comment: false\n  });\n  const stylesheets = html.querySelectorAll('style').map(styleNode => styleNode.childNodes.map(textNode => textNode.rawText.trim()).join('\\n')).filter(styleText => !!styleText).map(exports.convertStylesheet);\n  return {\n    stylesheets,\n    rootElement: (0, exports.convertNode)(html)\n  };\n};\n\nexports.default = parseHtml;","map":{"version":3,"sources":["/Users/macbook/Documents/GitHub/React 3/billing-app/node_modules/react-pdf-html/dist/parse.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","convertNode","convertElementStyle","convertStylesheet","convertRule","node_html_parser_1","require","css_tree_1","supportedStyles_1","camelize","rule","source","declarations","children","filter","declaration","type","toArray","map","entry","assign","property","reduce","style","valueString","default","generate","includes","test","console","warn","stylesheet","response","parsed","parse","rules","_a","prelude","forEach","block","selector","selectorString","e","error","styleAttr","tag","firstRule","first","undefined","node","nodeType","NodeType","TEXT_NODE","rawText","COMMENT_NODE","ELEMENT_NODE","Error","html","content","childNodes","kindCounters","child","indexOfType","attributes","trim","tagName","toLowerCase","parseHtml","text","comment","stylesheets","querySelectorAll","styleNode","textNode","join","styleText","rootElement"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.convertNode = exports.convertElementStyle = exports.convertStylesheet = exports.convertRule = void 0;\nconst node_html_parser_1 = require(\"node-html-parser\");\nconst css_tree_1 = __importDefault(require(\"css-tree\"));\nconst supportedStyles_1 = __importDefault(require(\"./supportedStyles\"));\nconst camelize = require('camelize');\nconst convertRule = (rule, source = 'style') => {\n    const declarations = rule.children\n        .filter((declaration) => declaration.type === 'Declaration')\n        .toArray();\n    return declarations\n        .map((entry) => (Object.assign(Object.assign({}, entry), { property: camelize(entry.property) })))\n        .reduce((style, { property, value }) => {\n        const valueString = css_tree_1.default.generate(value);\n        if (property && value) {\n            if (!property || !supportedStyles_1.default.includes(property)) {\n                if ((property === 'background' &&\n                    /^#?[a-zA-Z0-9]+$/.test(valueString)) ||\n                    /^rgba?\\([0-9, ]+\\)$/i.test(valueString) ||\n                    /^hsla?\\([0-9.%, ]+\\)$/i.test(valueString)) {\n                    property = 'backgroundColor';\n                }\n                else {\n                    console.warn(`${source}: Found unsupported style \"${property}\"`, {\n                        property,\n                        value,\n                    });\n                }\n            }\n            style[property] = valueString;\n        }\n        return style;\n    }, {});\n};\nexports.convertRule = convertRule;\nconst convertStylesheet = (stylesheet) => {\n    const response = {};\n    try {\n        const parsed = css_tree_1.default.parse(stylesheet);\n        const rules = parsed.children.filter((rule) => { var _a; return rule.type === 'Rule' && ((_a = rule.prelude) === null || _a === void 0 ? void 0 : _a.type) === 'SelectorList'; });\n        rules.forEach((rule) => {\n            const style = (0, exports.convertRule)(rule.block);\n            if (rule.prelude.type !== 'SelectorList') {\n                return;\n            }\n            rule.prelude.children.forEach((selector) => {\n                const selectorString = css_tree_1.default.generate(selector);\n                response[selectorString] = style;\n            });\n        });\n    }\n    catch (e) {\n        console.error(`Error parsing stylesheet: \"${stylesheet}\"`, e);\n    }\n    return response;\n};\nexports.convertStylesheet = convertStylesheet;\nconst convertElementStyle = (styleAttr, tag) => {\n    try {\n        const parsed = css_tree_1.default.parse(`${tag} { ${styleAttr} }`);\n        const rules = parsed.children.filter((rule) => { var _a; return rule.type === 'Rule' && ((_a = rule.prelude) === null || _a === void 0 ? void 0 : _a.type) === 'SelectorList'; });\n        const firstRule = rules.first();\n        return firstRule ? (0, exports.convertRule)(firstRule.block, tag) : undefined;\n    }\n    catch (e) {\n        console.error(`Error parsing style attribute \"${styleAttr}\" for tag: ${tag}`, e);\n    }\n};\nexports.convertElementStyle = convertElementStyle;\nconst convertNode = (node) => {\n    if (node.nodeType === node_html_parser_1.NodeType.TEXT_NODE) {\n        return node.rawText;\n    }\n    if (node.nodeType === node_html_parser_1.NodeType.COMMENT_NODE) {\n        return '';\n    }\n    if (node.nodeType !== node_html_parser_1.NodeType.ELEMENT_NODE) {\n        throw new Error('Not sure what this is');\n    }\n    const html = node;\n    const content = html.childNodes.map(exports.convertNode);\n    const kindCounters = {};\n    content.forEach((child) => {\n        if (typeof child !== 'string') {\n            child.indexOfType =\n                child.tag in kindCounters\n                    ? (kindCounters[child.tag] = kindCounters[child.tag] + 1)\n                    : (kindCounters[child.tag] = 0);\n        }\n    });\n    let style;\n    if (html.attributes.style && html.attributes.style.trim()) {\n        style = (0, exports.convertElementStyle)(html.attributes.style, html.tagName);\n    }\n    return Object.assign(html, {\n        tag: (html.tagName || '').toLowerCase(),\n        style: style ? [style] : [],\n        content,\n        indexOfType: 0,\n    });\n};\nexports.convertNode = convertNode;\nconst parseHtml = (text) => {\n    const html = (0, node_html_parser_1.parse)(text, { comment: false });\n    const stylesheets = html\n        .querySelectorAll('style')\n        .map((styleNode) => styleNode.childNodes.map((textNode) => textNode.rawText.trim()).join('\\n'))\n        .filter((styleText) => !!styleText)\n        .map(exports.convertStylesheet);\n    return {\n        stylesheets,\n        rootElement: (0, exports.convertNode)(html),\n    };\n};\nexports.default = parseHtml;\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"script"}