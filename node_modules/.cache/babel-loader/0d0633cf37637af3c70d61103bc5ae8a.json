{"ast":null,"code":"var List = require('../common/List');\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction isValidNumber(value) {\n  // Number.isInteger(value) && value >= 0\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value && value >= 0;\n}\n\nfunction isValidLocation(loc) {\n  return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);\n}\n\nfunction createNodeStructureChecker(type, fields) {\n  return function checkNode(node, warn) {\n    if (!node || node.constructor !== Object) {\n      return warn(node, 'Type of node should be an Object');\n    }\n\n    for (var key in node) {\n      var valid = true;\n\n      if (hasOwnProperty.call(node, key) === false) {\n        continue;\n      }\n\n      if (key === 'type') {\n        if (node.type !== type) {\n          warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');\n        }\n      } else if (key === 'loc') {\n        if (node.loc === null) {\n          continue;\n        } else if (node.loc && node.loc.constructor === Object) {\n          if (typeof node.loc.source !== 'string') {\n            key += '.source';\n          } else if (!isValidLocation(node.loc.start)) {\n            key += '.start';\n          } else if (!isValidLocation(node.loc.end)) {\n            key += '.end';\n          } else {\n            continue;\n          }\n        }\n\n        valid = false;\n      } else if (fields.hasOwnProperty(key)) {\n        for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {\n          var fieldType = fields[key][i];\n\n          switch (fieldType) {\n            case String:\n              valid = typeof node[key] === 'string';\n              break;\n\n            case Boolean:\n              valid = typeof node[key] === 'boolean';\n              break;\n\n            case null:\n              valid = node[key] === null;\n              break;\n\n            default:\n              if (typeof fieldType === 'string') {\n                valid = node[key] && node[key].type === fieldType;\n              } else if (Array.isArray(fieldType)) {\n                valid = node[key] instanceof List;\n              }\n\n          }\n        }\n      } else {\n        warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');\n      }\n\n      if (!valid) {\n        warn(node, 'Bad value for `' + type + '.' + key + '`');\n      }\n    }\n\n    for (var key in fields) {\n      if (hasOwnProperty.call(fields, key) && hasOwnProperty.call(node, key) === false) {\n        warn(node, 'Field `' + type + '.' + key + '` is missed');\n      }\n    }\n  };\n}\n\nfunction processStructure(name, nodeType) {\n  var structure = nodeType.structure;\n  var fields = {\n    type: String,\n    loc: true\n  };\n  var docs = {\n    type: '\"' + name + '\"'\n  };\n\n  for (var key in structure) {\n    if (hasOwnProperty.call(structure, key) === false) {\n      continue;\n    }\n\n    var docsTypes = [];\n    var fieldTypes = fields[key] = Array.isArray(structure[key]) ? structure[key].slice() : [structure[key]];\n\n    for (var i = 0; i < fieldTypes.length; i++) {\n      var fieldType = fieldTypes[i];\n\n      if (fieldType === String || fieldType === Boolean) {\n        docsTypes.push(fieldType.name);\n      } else if (fieldType === null) {\n        docsTypes.push('null');\n      } else if (typeof fieldType === 'string') {\n        docsTypes.push('<' + fieldType + '>');\n      } else if (Array.isArray(fieldType)) {\n        docsTypes.push('List'); // TODO: use type enum\n      } else {\n        throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');\n      }\n    }\n\n    docs[key] = docsTypes.join(' | ');\n  }\n\n  return {\n    docs: docs,\n    check: createNodeStructureChecker(name, fields)\n  };\n}\n\nmodule.exports = {\n  getStructureFromConfig: function (config) {\n    var structure = {};\n\n    if (config.node) {\n      for (var name in config.node) {\n        if (hasOwnProperty.call(config.node, name)) {\n          var nodeType = config.node[name];\n\n          if (nodeType.structure) {\n            structure[name] = processStructure(name, nodeType);\n          } else {\n            throw new Error('Missed `structure` field in `' + name + '` node type definition');\n          }\n        }\n      }\n    }\n\n    return structure;\n  }\n};","map":{"version":3,"sources":["/Users/macbook/Documents/GitHub/React 3/billing-app/node_modules/react-pdf-html/node_modules/css-tree/lib/lexer/structure.js"],"names":["List","require","hasOwnProperty","Object","prototype","isValidNumber","value","isFinite","Math","floor","isValidLocation","loc","Boolean","offset","line","column","createNodeStructureChecker","type","fields","checkNode","node","warn","constructor","key","valid","call","source","start","end","i","length","fieldType","String","Array","isArray","processStructure","name","nodeType","structure","docs","docsTypes","fieldTypes","slice","push","Error","join","check","module","exports","getStructureFromConfig","config"],"mappings":"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","sourcesContent":["var List = require('../common/List');\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction isValidNumber(value) {\n    // Number.isInteger(value) && value >= 0\n    return (\n        typeof value === 'number' &&\n        isFinite(value) &&\n        Math.floor(value) === value &&\n        value >= 0\n    );\n}\n\nfunction isValidLocation(loc) {\n    return (\n        Boolean(loc) &&\n        isValidNumber(loc.offset) &&\n        isValidNumber(loc.line) &&\n        isValidNumber(loc.column)\n    );\n}\n\nfunction createNodeStructureChecker(type, fields) {\n    return function checkNode(node, warn) {\n        if (!node || node.constructor !== Object) {\n            return warn(node, 'Type of node should be an Object');\n        }\n\n        for (var key in node) {\n            var valid = true;\n\n            if (hasOwnProperty.call(node, key) === false) {\n                continue;\n            }\n\n            if (key === 'type') {\n                if (node.type !== type) {\n                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');\n                }\n            } else if (key === 'loc') {\n                if (node.loc === null) {\n                    continue;\n                } else if (node.loc && node.loc.constructor === Object) {\n                    if (typeof node.loc.source !== 'string') {\n                        key += '.source';\n                    } else if (!isValidLocation(node.loc.start)) {\n                        key += '.start';\n                    } else if (!isValidLocation(node.loc.end)) {\n                        key += '.end';\n                    } else {\n                        continue;\n                    }\n                }\n\n                valid = false;\n            } else if (fields.hasOwnProperty(key)) {\n                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {\n                    var fieldType = fields[key][i];\n\n                    switch (fieldType) {\n                        case String:\n                            valid = typeof node[key] === 'string';\n                            break;\n\n                        case Boolean:\n                            valid = typeof node[key] === 'boolean';\n                            break;\n\n                        case null:\n                            valid = node[key] === null;\n                            break;\n\n                        default:\n                            if (typeof fieldType === 'string') {\n                                valid = node[key] && node[key].type === fieldType;\n                            } else if (Array.isArray(fieldType)) {\n                                valid = node[key] instanceof List;\n                            }\n                    }\n                }\n            } else {\n                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');\n            }\n\n            if (!valid) {\n                warn(node, 'Bad value for `' + type + '.' + key + '`');\n            }\n        }\n\n        for (var key in fields) {\n            if (hasOwnProperty.call(fields, key) &&\n                hasOwnProperty.call(node, key) === false) {\n                warn(node, 'Field `' + type + '.' + key + '` is missed');\n            }\n        }\n    };\n}\n\nfunction processStructure(name, nodeType) {\n    var structure = nodeType.structure;\n    var fields = {\n        type: String,\n        loc: true\n    };\n    var docs = {\n        type: '\"' + name + '\"'\n    };\n\n    for (var key in structure) {\n        if (hasOwnProperty.call(structure, key) === false) {\n            continue;\n        }\n\n        var docsTypes = [];\n        var fieldTypes = fields[key] = Array.isArray(structure[key])\n            ? structure[key].slice()\n            : [structure[key]];\n\n        for (var i = 0; i < fieldTypes.length; i++) {\n            var fieldType = fieldTypes[i];\n            if (fieldType === String || fieldType === Boolean) {\n                docsTypes.push(fieldType.name);\n            } else if (fieldType === null) {\n                docsTypes.push('null');\n            } else if (typeof fieldType === 'string') {\n                docsTypes.push('<' + fieldType + '>');\n            } else if (Array.isArray(fieldType)) {\n                docsTypes.push('List'); // TODO: use type enum\n            } else {\n                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');\n            }\n        }\n\n        docs[key] = docsTypes.join(' | ');\n    }\n\n    return {\n        docs: docs,\n        check: createNodeStructureChecker(name, fields)\n    };\n}\n\nmodule.exports = {\n    getStructureFromConfig: function(config) {\n        var structure = {};\n\n        if (config.node) {\n            for (var name in config.node) {\n                if (hasOwnProperty.call(config.node, name)) {\n                    var nodeType = config.node[name];\n\n                    if (nodeType.structure) {\n                        structure[name] = processStructure(name, nodeType);\n                    } else {\n                        throw new Error('Missed `structure` field in `' + name + '` node type definition');\n                    }\n                }\n            }\n        }\n\n        return structure;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}