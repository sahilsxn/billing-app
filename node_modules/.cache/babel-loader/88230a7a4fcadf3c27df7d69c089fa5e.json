{"ast":null,"code":"const createCustomError = require('../utils/createCustomError');\n\nconst generate = require('../definition-syntax/generate');\n\nconst defaultLoc = {\n  offset: 0,\n  line: 1,\n  column: 1\n};\n\nfunction locateMismatch(matchResult, node) {\n  const tokens = matchResult.tokens;\n  const longestMatch = matchResult.longestMatch;\n  const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;\n  const badNode = mismatchNode !== node ? mismatchNode : null;\n  let mismatchOffset = 0;\n  let mismatchLength = 0;\n  let entries = 0;\n  let css = '';\n  let start;\n  let end;\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i].value;\n\n    if (i === longestMatch) {\n      mismatchLength = token.length;\n      mismatchOffset = css.length;\n    }\n\n    if (badNode !== null && tokens[i].node === badNode) {\n      if (i <= longestMatch) {\n        entries++;\n      } else {\n        entries = 0;\n      }\n    }\n\n    css += token;\n  }\n\n  if (longestMatch === tokens.length || entries > 1) {\n    // last\n    start = fromLoc(badNode || node, 'end') || buildLoc(defaultLoc, css);\n    end = buildLoc(start);\n  } else {\n    start = fromLoc(badNode, 'start') || buildLoc(fromLoc(node, 'start') || defaultLoc, css.slice(0, mismatchOffset));\n    end = fromLoc(badNode, 'end') || buildLoc(start, css.substr(mismatchOffset, mismatchLength));\n  }\n\n  return {\n    css,\n    mismatchOffset,\n    mismatchLength,\n    start,\n    end\n  };\n}\n\nfunction fromLoc(node, point) {\n  const value = node && node.loc && node.loc[point];\n\n  if (value) {\n    return 'line' in value ? buildLoc(value) : value;\n  }\n\n  return null;\n}\n\nfunction buildLoc(_ref, extra) {\n  let {\n    offset,\n    line,\n    column\n  } = _ref;\n  const loc = {\n    offset,\n    line,\n    column\n  };\n\n  if (extra) {\n    const lines = extra.split(/\\n|\\r\\n?|\\f/);\n    loc.offset += extra.length;\n    loc.line += lines.length - 1;\n    loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;\n  }\n\n  return loc;\n}\n\nconst SyntaxReferenceError = function (type, referenceName) {\n  const error = createCustomError('SyntaxReferenceError', type + (referenceName ? ' `' + referenceName + '`' : ''));\n  error.reference = referenceName;\n  return error;\n};\n\nconst SyntaxMatchError = function (message, syntax, node, matchResult) {\n  const error = createCustomError('SyntaxMatchError', message);\n  const {\n    css,\n    mismatchOffset,\n    mismatchLength,\n    start,\n    end\n  } = locateMismatch(matchResult, node);\n  error.rawMessage = message;\n  error.syntax = syntax ? generate(syntax) : '<generic>';\n  error.css = css;\n  error.mismatchOffset = mismatchOffset;\n  error.mismatchLength = mismatchLength;\n  error.message = message + '\\n' + '  syntax: ' + error.syntax + '\\n' + '   value: ' + (css || '<empty string>') + '\\n' + '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';\n  Object.assign(error, start);\n  error.loc = {\n    source: node && node.loc && node.loc.source || '<unknown>',\n    start,\n    end\n  };\n  return error;\n};\n\nmodule.exports = {\n  SyntaxReferenceError,\n  SyntaxMatchError\n};","map":{"version":3,"sources":["/Users/macbook/Documents/GitHub/React 3/billing-app/node_modules/react-pdf-html/node_modules/css-tree/lib/lexer/error.js"],"names":["createCustomError","require","generate","defaultLoc","offset","line","column","locateMismatch","matchResult","node","tokens","longestMatch","mismatchNode","length","badNode","mismatchOffset","mismatchLength","entries","css","start","end","i","token","value","fromLoc","buildLoc","slice","substr","point","loc","extra","lines","split","pop","SyntaxReferenceError","type","referenceName","error","reference","SyntaxMatchError","message","syntax","rawMessage","Array","join","Object","assign","source","module","exports"],"mappings":"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","sourcesContent":["const createCustomError = require('../utils/createCustomError');\nconst generate = require('../definition-syntax/generate');\nconst defaultLoc = { offset: 0, line: 1, column: 1 };\n\nfunction locateMismatch(matchResult, node) {\n    const tokens = matchResult.tokens;\n    const longestMatch = matchResult.longestMatch;\n    const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;\n    const badNode = mismatchNode !== node ? mismatchNode : null;\n    let mismatchOffset = 0;\n    let mismatchLength = 0;\n    let entries = 0;\n    let css = '';\n    let start;\n    let end;\n\n    for (let i = 0; i < tokens.length; i++) {\n        const token = tokens[i].value;\n\n        if (i === longestMatch) {\n            mismatchLength = token.length;\n            mismatchOffset = css.length;\n        }\n\n        if (badNode !== null && tokens[i].node === badNode) {\n            if (i <= longestMatch) {\n                entries++;\n            } else {\n                entries = 0;\n            }\n        }\n\n        css += token;\n    }\n\n    if (longestMatch === tokens.length || entries > 1) { // last\n        start = fromLoc(badNode || node, 'end') || buildLoc(defaultLoc, css);\n        end = buildLoc(start);\n    } else {\n        start = fromLoc(badNode, 'start') ||\n            buildLoc(fromLoc(node, 'start') || defaultLoc, css.slice(0, mismatchOffset));\n        end = fromLoc(badNode, 'end') ||\n            buildLoc(start, css.substr(mismatchOffset, mismatchLength));\n    }\n\n    return {\n        css,\n        mismatchOffset,\n        mismatchLength,\n        start,\n        end\n    };\n}\n\nfunction fromLoc(node, point) {\n    const value = node && node.loc && node.loc[point];\n\n    if (value) {\n        return 'line' in value ? buildLoc(value) : value;\n    }\n\n    return null;\n}\n\nfunction buildLoc({ offset, line, column }, extra) {\n    const loc = {\n        offset,\n        line,\n        column\n    };\n\n    if (extra) {\n        const lines = extra.split(/\\n|\\r\\n?|\\f/);\n\n        loc.offset += extra.length;\n        loc.line += lines.length - 1;\n        loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;\n    }\n\n    return loc;\n}\n\nconst SyntaxReferenceError = function(type, referenceName) {\n    const error = createCustomError(\n        'SyntaxReferenceError',\n        type + (referenceName ? ' `' + referenceName + '`' : '')\n    );\n\n    error.reference = referenceName;\n\n    return error;\n};\n\nconst SyntaxMatchError = function(message, syntax, node, matchResult) {\n    const error = createCustomError('SyntaxMatchError', message);\n    const {\n        css,\n        mismatchOffset,\n        mismatchLength,\n        start,\n        end\n    } = locateMismatch(matchResult, node);\n\n    error.rawMessage = message;\n    error.syntax = syntax ? generate(syntax) : '<generic>';\n    error.css = css;\n    error.mismatchOffset = mismatchOffset;\n    error.mismatchLength = mismatchLength;\n    error.message = message + '\\n' +\n        '  syntax: ' + error.syntax + '\\n' +\n        '   value: ' + (css || '<empty string>') + '\\n' +\n        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';\n\n    Object.assign(error, start);\n    error.loc = {\n        source: (node && node.loc && node.loc.source) || '<unknown>',\n        start,\n        end\n    };\n\n    return error;\n};\n\nmodule.exports = {\n    SyntaxReferenceError,\n    SyntaxMatchError\n};\n"]},"metadata":{},"sourceType":"script"}