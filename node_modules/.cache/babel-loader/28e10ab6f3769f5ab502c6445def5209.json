{"ast":null,"code":"var Tokenizer = require('./tokenizer');\n\nvar TAB = 9;\nvar N = 10;\nvar F = 12;\nvar R = 13;\nvar SPACE = 32;\nvar EXCLAMATIONMARK = 33; // !\n\nvar NUMBERSIGN = 35; // #\n\nvar AMPERSAND = 38; // &\n\nvar APOSTROPHE = 39; // '\n\nvar LEFTPARENTHESIS = 40; // (\n\nvar RIGHTPARENTHESIS = 41; // )\n\nvar ASTERISK = 42; // *\n\nvar PLUSSIGN = 43; // +\n\nvar COMMA = 44; // ,\n\nvar HYPERMINUS = 45; // -\n\nvar LESSTHANSIGN = 60; // <\n\nvar GREATERTHANSIGN = 62; // >\n\nvar QUESTIONMARK = 63; // ?\n\nvar COMMERCIALAT = 64; // @\n\nvar LEFTSQUAREBRACKET = 91; // [\n\nvar RIGHTSQUAREBRACKET = 93; // ]\n\nvar LEFTCURLYBRACKET = 123; // {\n\nvar VERTICALLINE = 124; // |\n\nvar RIGHTCURLYBRACKET = 125; // }\n\nvar INFINITY = 8734; // ∞\n\nvar NAME_CHAR = createCharMap(function (ch) {\n  return /[a-zA-Z0-9\\-]/.test(ch);\n});\nvar COMBINATOR_PRECEDENCE = {\n  ' ': 1,\n  '&&': 2,\n  '||': 3,\n  '|': 4\n};\n\nfunction createCharMap(fn) {\n  var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);\n\n  for (var i = 0; i < 128; i++) {\n    array[i] = fn(String.fromCharCode(i)) ? 1 : 0;\n  }\n\n  return array;\n}\n\nfunction scanSpaces(tokenizer) {\n  return tokenizer.substringToPos(tokenizer.findWsEnd(tokenizer.pos));\n}\n\nfunction scanWord(tokenizer) {\n  var end = tokenizer.pos;\n\n  for (; end < tokenizer.str.length; end++) {\n    var code = tokenizer.str.charCodeAt(end);\n\n    if (code >= 128 || NAME_CHAR[code] === 0) {\n      break;\n    }\n  }\n\n  if (tokenizer.pos === end) {\n    tokenizer.error('Expect a keyword');\n  }\n\n  return tokenizer.substringToPos(end);\n}\n\nfunction scanNumber(tokenizer) {\n  var end = tokenizer.pos;\n\n  for (; end < tokenizer.str.length; end++) {\n    var code = tokenizer.str.charCodeAt(end);\n\n    if (code < 48 || code > 57) {\n      break;\n    }\n  }\n\n  if (tokenizer.pos === end) {\n    tokenizer.error('Expect a number');\n  }\n\n  return tokenizer.substringToPos(end);\n}\n\nfunction scanString(tokenizer) {\n  var end = tokenizer.str.indexOf('\\'', tokenizer.pos + 1);\n\n  if (end === -1) {\n    tokenizer.pos = tokenizer.str.length;\n    tokenizer.error('Expect an apostrophe');\n  }\n\n  return tokenizer.substringToPos(end + 1);\n}\n\nfunction readMultiplierRange(tokenizer) {\n  var min = null;\n  var max = null;\n  tokenizer.eat(LEFTCURLYBRACKET);\n  min = scanNumber(tokenizer);\n\n  if (tokenizer.charCode() === COMMA) {\n    tokenizer.pos++;\n\n    if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {\n      max = scanNumber(tokenizer);\n    }\n  } else {\n    max = min;\n  }\n\n  tokenizer.eat(RIGHTCURLYBRACKET);\n  return {\n    min: Number(min),\n    max: max ? Number(max) : 0\n  };\n}\n\nfunction readMultiplier(tokenizer) {\n  var range = null;\n  var comma = false;\n\n  switch (tokenizer.charCode()) {\n    case ASTERISK:\n      tokenizer.pos++;\n      range = {\n        min: 0,\n        max: 0\n      };\n      break;\n\n    case PLUSSIGN:\n      tokenizer.pos++;\n      range = {\n        min: 1,\n        max: 0\n      };\n      break;\n\n    case QUESTIONMARK:\n      tokenizer.pos++;\n      range = {\n        min: 0,\n        max: 1\n      };\n      break;\n\n    case NUMBERSIGN:\n      tokenizer.pos++;\n      comma = true;\n\n      if (tokenizer.charCode() === LEFTCURLYBRACKET) {\n        range = readMultiplierRange(tokenizer);\n      } else {\n        range = {\n          min: 1,\n          max: 0\n        };\n      }\n\n      break;\n\n    case LEFTCURLYBRACKET:\n      range = readMultiplierRange(tokenizer);\n      break;\n\n    default:\n      return null;\n  }\n\n  return {\n    type: 'Multiplier',\n    comma: comma,\n    min: range.min,\n    max: range.max,\n    term: null\n  };\n}\n\nfunction maybeMultiplied(tokenizer, node) {\n  var multiplier = readMultiplier(tokenizer);\n\n  if (multiplier !== null) {\n    multiplier.term = node;\n    return multiplier;\n  }\n\n  return node;\n}\n\nfunction maybeToken(tokenizer) {\n  var ch = tokenizer.peek();\n\n  if (ch === '') {\n    return null;\n  }\n\n  return {\n    type: 'Token',\n    value: ch\n  };\n}\n\nfunction readProperty(tokenizer) {\n  var name;\n  tokenizer.eat(LESSTHANSIGN);\n  tokenizer.eat(APOSTROPHE);\n  name = scanWord(tokenizer);\n  tokenizer.eat(APOSTROPHE);\n  tokenizer.eat(GREATERTHANSIGN);\n  return maybeMultiplied(tokenizer, {\n    type: 'Property',\n    name: name\n  });\n} // https://drafts.csswg.org/css-values-3/#numeric-ranges\n// 4.1. Range Restrictions and Range Definition Notation\n//\n// Range restrictions can be annotated in the numeric type notation using CSS bracketed\n// range notation—[min,max]—within the angle brackets, after the identifying keyword,\n// indicating a closed range between (and including) min and max.\n// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.\n\n\nfunction readTypeRange(tokenizer) {\n  // use null for Infinity to make AST format JSON serializable/deserializable\n  var min = null; // -Infinity\n\n  var max = null; // Infinity\n\n  var sign = 1;\n  tokenizer.eat(LEFTSQUAREBRACKET);\n\n  if (tokenizer.charCode() === HYPERMINUS) {\n    tokenizer.peek();\n    sign = -1;\n  }\n\n  if (sign == -1 && tokenizer.charCode() === INFINITY) {\n    tokenizer.peek();\n  } else {\n    min = sign * Number(scanNumber(tokenizer));\n  }\n\n  scanSpaces(tokenizer);\n  tokenizer.eat(COMMA);\n  scanSpaces(tokenizer);\n\n  if (tokenizer.charCode() === INFINITY) {\n    tokenizer.peek();\n  } else {\n    sign = 1;\n\n    if (tokenizer.charCode() === HYPERMINUS) {\n      tokenizer.peek();\n      sign = -1;\n    }\n\n    max = sign * Number(scanNumber(tokenizer));\n  }\n\n  tokenizer.eat(RIGHTSQUAREBRACKET); // If no range is indicated, either by using the bracketed range notation\n  // or in the property description, then [−∞,∞] is assumed.\n\n  if (min === null && max === null) {\n    return null;\n  }\n\n  return {\n    type: 'Range',\n    min: min,\n    max: max\n  };\n}\n\nfunction readType(tokenizer) {\n  var name;\n  var opts = null;\n  tokenizer.eat(LESSTHANSIGN);\n  name = scanWord(tokenizer);\n\n  if (tokenizer.charCode() === LEFTPARENTHESIS && tokenizer.nextCharCode() === RIGHTPARENTHESIS) {\n    tokenizer.pos += 2;\n    name += '()';\n  }\n\n  if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {\n    scanSpaces(tokenizer);\n    opts = readTypeRange(tokenizer);\n  }\n\n  tokenizer.eat(GREATERTHANSIGN);\n  return maybeMultiplied(tokenizer, {\n    type: 'Type',\n    name: name,\n    opts: opts\n  });\n}\n\nfunction readKeywordOrFunction(tokenizer) {\n  var name;\n  name = scanWord(tokenizer);\n\n  if (tokenizer.charCode() === LEFTPARENTHESIS) {\n    tokenizer.pos++;\n    return {\n      type: 'Function',\n      name: name\n    };\n  }\n\n  return maybeMultiplied(tokenizer, {\n    type: 'Keyword',\n    name: name\n  });\n}\n\nfunction regroupTerms(terms, combinators) {\n  function createGroup(terms, combinator) {\n    return {\n      type: 'Group',\n      terms: terms,\n      combinator: combinator,\n      disallowEmpty: false,\n      explicit: false\n    };\n  }\n\n  combinators = Object.keys(combinators).sort(function (a, b) {\n    return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];\n  });\n\n  while (combinators.length > 0) {\n    var combinator = combinators.shift();\n\n    for (var i = 0, subgroupStart = 0; i < terms.length; i++) {\n      var term = terms[i];\n\n      if (term.type === 'Combinator') {\n        if (term.value === combinator) {\n          if (subgroupStart === -1) {\n            subgroupStart = i - 1;\n          }\n\n          terms.splice(i, 1);\n          i--;\n        } else {\n          if (subgroupStart !== -1 && i - subgroupStart > 1) {\n            terms.splice(subgroupStart, i - subgroupStart, createGroup(terms.slice(subgroupStart, i), combinator));\n            i = subgroupStart + 1;\n          }\n\n          subgroupStart = -1;\n        }\n      }\n    }\n\n    if (subgroupStart !== -1 && combinators.length) {\n      terms.splice(subgroupStart, i - subgroupStart, createGroup(terms.slice(subgroupStart, i), combinator));\n    }\n  }\n\n  return combinator;\n}\n\nfunction readImplicitGroup(tokenizer) {\n  var terms = [];\n  var combinators = {};\n  var token;\n  var prevToken = null;\n  var prevTokenPos = tokenizer.pos;\n\n  while (token = peek(tokenizer)) {\n    if (token.type !== 'Spaces') {\n      if (token.type === 'Combinator') {\n        // check for combinator in group beginning and double combinator sequence\n        if (prevToken === null || prevToken.type === 'Combinator') {\n          tokenizer.pos = prevTokenPos;\n          tokenizer.error('Unexpected combinator');\n        }\n\n        combinators[token.value] = true;\n      } else if (prevToken !== null && prevToken.type !== 'Combinator') {\n        combinators[' '] = true; // a b\n\n        terms.push({\n          type: 'Combinator',\n          value: ' '\n        });\n      }\n\n      terms.push(token);\n      prevToken = token;\n      prevTokenPos = tokenizer.pos;\n    }\n  } // check for combinator in group ending\n\n\n  if (prevToken !== null && prevToken.type === 'Combinator') {\n    tokenizer.pos -= prevTokenPos;\n    tokenizer.error('Unexpected combinator');\n  }\n\n  return {\n    type: 'Group',\n    terms: terms,\n    combinator: regroupTerms(terms, combinators) || ' ',\n    disallowEmpty: false,\n    explicit: false\n  };\n}\n\nfunction readGroup(tokenizer) {\n  var result;\n  tokenizer.eat(LEFTSQUAREBRACKET);\n  result = readImplicitGroup(tokenizer);\n  tokenizer.eat(RIGHTSQUAREBRACKET);\n  result.explicit = true;\n\n  if (tokenizer.charCode() === EXCLAMATIONMARK) {\n    tokenizer.pos++;\n    result.disallowEmpty = true;\n  }\n\n  return result;\n}\n\nfunction peek(tokenizer) {\n  var code = tokenizer.charCode();\n\n  if (code < 128 && NAME_CHAR[code] === 1) {\n    return readKeywordOrFunction(tokenizer);\n  }\n\n  switch (code) {\n    case RIGHTSQUAREBRACKET:\n      // don't eat, stop scan a group\n      break;\n\n    case LEFTSQUAREBRACKET:\n      return maybeMultiplied(tokenizer, readGroup(tokenizer));\n\n    case LESSTHANSIGN:\n      return tokenizer.nextCharCode() === APOSTROPHE ? readProperty(tokenizer) : readType(tokenizer);\n\n    case VERTICALLINE:\n      return {\n        type: 'Combinator',\n        value: tokenizer.substringToPos(tokenizer.nextCharCode() === VERTICALLINE ? tokenizer.pos + 2 : tokenizer.pos + 1)\n      };\n\n    case AMPERSAND:\n      tokenizer.pos++;\n      tokenizer.eat(AMPERSAND);\n      return {\n        type: 'Combinator',\n        value: '&&'\n      };\n\n    case COMMA:\n      tokenizer.pos++;\n      return {\n        type: 'Comma'\n      };\n\n    case APOSTROPHE:\n      return maybeMultiplied(tokenizer, {\n        type: 'String',\n        value: scanString(tokenizer)\n      });\n\n    case SPACE:\n    case TAB:\n    case N:\n    case R:\n    case F:\n      return {\n        type: 'Spaces',\n        value: scanSpaces(tokenizer)\n      };\n\n    case COMMERCIALAT:\n      code = tokenizer.nextCharCode();\n\n      if (code < 128 && NAME_CHAR[code] === 1) {\n        tokenizer.pos++;\n        return {\n          type: 'AtKeyword',\n          name: scanWord(tokenizer)\n        };\n      }\n\n      return maybeToken(tokenizer);\n\n    case ASTERISK:\n    case PLUSSIGN:\n    case QUESTIONMARK:\n    case NUMBERSIGN:\n    case EXCLAMATIONMARK:\n      // prohibited tokens (used as a multiplier start)\n      break;\n\n    case LEFTCURLYBRACKET:\n      // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting\n      // check next char isn't a number, because it's likely a disjoined multiplier\n      code = tokenizer.nextCharCode();\n\n      if (code < 48 || code > 57) {\n        return maybeToken(tokenizer);\n      }\n\n      break;\n\n    default:\n      return maybeToken(tokenizer);\n  }\n}\n\nfunction parse(source) {\n  var tokenizer = new Tokenizer(source);\n  var result = readImplicitGroup(tokenizer);\n\n  if (tokenizer.pos !== source.length) {\n    tokenizer.error('Unexpected input');\n  } // reduce redundant groups with single group term\n\n\n  if (result.terms.length === 1 && result.terms[0].type === 'Group') {\n    result = result.terms[0];\n  }\n\n  return result;\n} // warm up parse to elimitate code branches that never execute\n// fix soft deoptimizations (insufficient type feedback)\n\n\nparse('[a&&<b>#|<\\'c\\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');\nmodule.exports = parse;","map":{"version":3,"sources":["/Users/macbook/Documents/GitHub/React 3/billing-app/node_modules/react-pdf-html/node_modules/css-tree/lib/definition-syntax/parse.js"],"names":["Tokenizer","require","TAB","N","F","R","SPACE","EXCLAMATIONMARK","NUMBERSIGN","AMPERSAND","APOSTROPHE","LEFTPARENTHESIS","RIGHTPARENTHESIS","ASTERISK","PLUSSIGN","COMMA","HYPERMINUS","LESSTHANSIGN","GREATERTHANSIGN","QUESTIONMARK","COMMERCIALAT","LEFTSQUAREBRACKET","RIGHTSQUAREBRACKET","LEFTCURLYBRACKET","VERTICALLINE","RIGHTCURLYBRACKET","INFINITY","NAME_CHAR","createCharMap","ch","test","COMBINATOR_PRECEDENCE","fn","array","Uint32Array","Array","i","String","fromCharCode","scanSpaces","tokenizer","substringToPos","findWsEnd","pos","scanWord","end","str","length","code","charCodeAt","error","scanNumber","scanString","indexOf","readMultiplierRange","min","max","eat","charCode","Number","readMultiplier","range","comma","type","term","maybeMultiplied","node","multiplier","maybeToken","peek","value","readProperty","name","readTypeRange","sign","readType","opts","nextCharCode","readKeywordOrFunction","regroupTerms","terms","combinators","createGroup","combinator","disallowEmpty","explicit","Object","keys","sort","a","b","shift","subgroupStart","splice","slice","readImplicitGroup","token","prevToken","prevTokenPos","push","readGroup","result","parse","source","module","exports"],"mappings":"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","sourcesContent":["var Tokenizer = require('./tokenizer');\nvar TAB = 9;\nvar N = 10;\nvar F = 12;\nvar R = 13;\nvar SPACE = 32;\nvar EXCLAMATIONMARK = 33;    // !\nvar NUMBERSIGN = 35;         // #\nvar AMPERSAND = 38;          // &\nvar APOSTROPHE = 39;         // '\nvar LEFTPARENTHESIS = 40;    // (\nvar RIGHTPARENTHESIS = 41;   // )\nvar ASTERISK = 42;           // *\nvar PLUSSIGN = 43;           // +\nvar COMMA = 44;              // ,\nvar HYPERMINUS = 45;         // -\nvar LESSTHANSIGN = 60;       // <\nvar GREATERTHANSIGN = 62;    // >\nvar QUESTIONMARK = 63;       // ?\nvar COMMERCIALAT = 64;       // @\nvar LEFTSQUAREBRACKET = 91;  // [\nvar RIGHTSQUAREBRACKET = 93; // ]\nvar LEFTCURLYBRACKET = 123;  // {\nvar VERTICALLINE = 124;      // |\nvar RIGHTCURLYBRACKET = 125; // }\nvar INFINITY = 8734;         // ∞\nvar NAME_CHAR = createCharMap(function(ch) {\n    return /[a-zA-Z0-9\\-]/.test(ch);\n});\nvar COMBINATOR_PRECEDENCE = {\n    ' ': 1,\n    '&&': 2,\n    '||': 3,\n    '|': 4\n};\n\nfunction createCharMap(fn) {\n    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);\n    for (var i = 0; i < 128; i++) {\n        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;\n    }\n    return array;\n}\n\nfunction scanSpaces(tokenizer) {\n    return tokenizer.substringToPos(\n        tokenizer.findWsEnd(tokenizer.pos)\n    );\n}\n\nfunction scanWord(tokenizer) {\n    var end = tokenizer.pos;\n\n    for (; end < tokenizer.str.length; end++) {\n        var code = tokenizer.str.charCodeAt(end);\n        if (code >= 128 || NAME_CHAR[code] === 0) {\n            break;\n        }\n    }\n\n    if (tokenizer.pos === end) {\n        tokenizer.error('Expect a keyword');\n    }\n\n    return tokenizer.substringToPos(end);\n}\n\nfunction scanNumber(tokenizer) {\n    var end = tokenizer.pos;\n\n    for (; end < tokenizer.str.length; end++) {\n        var code = tokenizer.str.charCodeAt(end);\n        if (code < 48 || code > 57) {\n            break;\n        }\n    }\n\n    if (tokenizer.pos === end) {\n        tokenizer.error('Expect a number');\n    }\n\n    return tokenizer.substringToPos(end);\n}\n\nfunction scanString(tokenizer) {\n    var end = tokenizer.str.indexOf('\\'', tokenizer.pos + 1);\n\n    if (end === -1) {\n        tokenizer.pos = tokenizer.str.length;\n        tokenizer.error('Expect an apostrophe');\n    }\n\n    return tokenizer.substringToPos(end + 1);\n}\n\nfunction readMultiplierRange(tokenizer) {\n    var min = null;\n    var max = null;\n\n    tokenizer.eat(LEFTCURLYBRACKET);\n\n    min = scanNumber(tokenizer);\n\n    if (tokenizer.charCode() === COMMA) {\n        tokenizer.pos++;\n        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {\n            max = scanNumber(tokenizer);\n        }\n    } else {\n        max = min;\n    }\n\n    tokenizer.eat(RIGHTCURLYBRACKET);\n\n    return {\n        min: Number(min),\n        max: max ? Number(max) : 0\n    };\n}\n\nfunction readMultiplier(tokenizer) {\n    var range = null;\n    var comma = false;\n\n    switch (tokenizer.charCode()) {\n        case ASTERISK:\n            tokenizer.pos++;\n\n            range = {\n                min: 0,\n                max: 0\n            };\n\n            break;\n\n        case PLUSSIGN:\n            tokenizer.pos++;\n\n            range = {\n                min: 1,\n                max: 0\n            };\n\n            break;\n\n        case QUESTIONMARK:\n            tokenizer.pos++;\n\n            range = {\n                min: 0,\n                max: 1\n            };\n\n            break;\n\n        case NUMBERSIGN:\n            tokenizer.pos++;\n\n            comma = true;\n\n            if (tokenizer.charCode() === LEFTCURLYBRACKET) {\n                range = readMultiplierRange(tokenizer);\n            } else {\n                range = {\n                    min: 1,\n                    max: 0\n                };\n            }\n\n            break;\n\n        case LEFTCURLYBRACKET:\n            range = readMultiplierRange(tokenizer);\n            break;\n\n        default:\n            return null;\n    }\n\n    return {\n        type: 'Multiplier',\n        comma: comma,\n        min: range.min,\n        max: range.max,\n        term: null\n    };\n}\n\nfunction maybeMultiplied(tokenizer, node) {\n    var multiplier = readMultiplier(tokenizer);\n\n    if (multiplier !== null) {\n        multiplier.term = node;\n        return multiplier;\n    }\n\n    return node;\n}\n\nfunction maybeToken(tokenizer) {\n    var ch = tokenizer.peek();\n\n    if (ch === '') {\n        return null;\n    }\n\n    return {\n        type: 'Token',\n        value: ch\n    };\n}\n\nfunction readProperty(tokenizer) {\n    var name;\n\n    tokenizer.eat(LESSTHANSIGN);\n    tokenizer.eat(APOSTROPHE);\n\n    name = scanWord(tokenizer);\n\n    tokenizer.eat(APOSTROPHE);\n    tokenizer.eat(GREATERTHANSIGN);\n\n    return maybeMultiplied(tokenizer, {\n        type: 'Property',\n        name: name\n    });\n}\n\n// https://drafts.csswg.org/css-values-3/#numeric-ranges\n// 4.1. Range Restrictions and Range Definition Notation\n//\n// Range restrictions can be annotated in the numeric type notation using CSS bracketed\n// range notation—[min,max]—within the angle brackets, after the identifying keyword,\n// indicating a closed range between (and including) min and max.\n// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.\nfunction readTypeRange(tokenizer) {\n    // use null for Infinity to make AST format JSON serializable/deserializable\n    var min = null; // -Infinity\n    var max = null; // Infinity\n    var sign = 1;\n\n    tokenizer.eat(LEFTSQUAREBRACKET);\n\n    if (tokenizer.charCode() === HYPERMINUS) {\n        tokenizer.peek();\n        sign = -1;\n    }\n\n    if (sign == -1 && tokenizer.charCode() === INFINITY) {\n        tokenizer.peek();\n    } else {\n        min = sign * Number(scanNumber(tokenizer));\n    }\n\n    scanSpaces(tokenizer);\n    tokenizer.eat(COMMA);\n    scanSpaces(tokenizer);\n\n    if (tokenizer.charCode() === INFINITY) {\n        tokenizer.peek();\n    } else {\n        sign = 1;\n\n        if (tokenizer.charCode() === HYPERMINUS) {\n            tokenizer.peek();\n            sign = -1;\n        }\n\n        max = sign * Number(scanNumber(tokenizer));\n    }\n\n    tokenizer.eat(RIGHTSQUAREBRACKET);\n\n    // If no range is indicated, either by using the bracketed range notation\n    // or in the property description, then [−∞,∞] is assumed.\n    if (min === null && max === null) {\n        return null;\n    }\n\n    return {\n        type: 'Range',\n        min: min,\n        max: max\n    };\n}\n\nfunction readType(tokenizer) {\n    var name;\n    var opts = null;\n\n    tokenizer.eat(LESSTHANSIGN);\n    name = scanWord(tokenizer);\n\n    if (tokenizer.charCode() === LEFTPARENTHESIS &&\n        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {\n        tokenizer.pos += 2;\n        name += '()';\n    }\n\n    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {\n        scanSpaces(tokenizer);\n        opts = readTypeRange(tokenizer);\n    }\n\n    tokenizer.eat(GREATERTHANSIGN);\n\n    return maybeMultiplied(tokenizer, {\n        type: 'Type',\n        name: name,\n        opts: opts\n    });\n}\n\nfunction readKeywordOrFunction(tokenizer) {\n    var name;\n\n    name = scanWord(tokenizer);\n\n    if (tokenizer.charCode() === LEFTPARENTHESIS) {\n        tokenizer.pos++;\n\n        return {\n            type: 'Function',\n            name: name\n        };\n    }\n\n    return maybeMultiplied(tokenizer, {\n        type: 'Keyword',\n        name: name\n    });\n}\n\nfunction regroupTerms(terms, combinators) {\n    function createGroup(terms, combinator) {\n        return {\n            type: 'Group',\n            terms: terms,\n            combinator: combinator,\n            disallowEmpty: false,\n            explicit: false\n        };\n    }\n\n    combinators = Object.keys(combinators).sort(function(a, b) {\n        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];\n    });\n\n    while (combinators.length > 0) {\n        var combinator = combinators.shift();\n        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {\n            var term = terms[i];\n            if (term.type === 'Combinator') {\n                if (term.value === combinator) {\n                    if (subgroupStart === -1) {\n                        subgroupStart = i - 1;\n                    }\n                    terms.splice(i, 1);\n                    i--;\n                } else {\n                    if (subgroupStart !== -1 && i - subgroupStart > 1) {\n                        terms.splice(\n                            subgroupStart,\n                            i - subgroupStart,\n                            createGroup(terms.slice(subgroupStart, i), combinator)\n                        );\n                        i = subgroupStart + 1;\n                    }\n                    subgroupStart = -1;\n                }\n            }\n        }\n\n        if (subgroupStart !== -1 && combinators.length) {\n            terms.splice(\n                subgroupStart,\n                i - subgroupStart,\n                createGroup(terms.slice(subgroupStart, i), combinator)\n            );\n        }\n    }\n\n    return combinator;\n}\n\nfunction readImplicitGroup(tokenizer) {\n    var terms = [];\n    var combinators = {};\n    var token;\n    var prevToken = null;\n    var prevTokenPos = tokenizer.pos;\n\n    while (token = peek(tokenizer)) {\n        if (token.type !== 'Spaces') {\n            if (token.type === 'Combinator') {\n                // check for combinator in group beginning and double combinator sequence\n                if (prevToken === null || prevToken.type === 'Combinator') {\n                    tokenizer.pos = prevTokenPos;\n                    tokenizer.error('Unexpected combinator');\n                }\n\n                combinators[token.value] = true;\n            } else if (prevToken !== null && prevToken.type !== 'Combinator') {\n                combinators[' '] = true;  // a b\n                terms.push({\n                    type: 'Combinator',\n                    value: ' '\n                });\n            }\n\n            terms.push(token);\n            prevToken = token;\n            prevTokenPos = tokenizer.pos;\n        }\n    }\n\n    // check for combinator in group ending\n    if (prevToken !== null && prevToken.type === 'Combinator') {\n        tokenizer.pos -= prevTokenPos;\n        tokenizer.error('Unexpected combinator');\n    }\n\n    return {\n        type: 'Group',\n        terms: terms,\n        combinator: regroupTerms(terms, combinators) || ' ',\n        disallowEmpty: false,\n        explicit: false\n    };\n}\n\nfunction readGroup(tokenizer) {\n    var result;\n\n    tokenizer.eat(LEFTSQUAREBRACKET);\n    result = readImplicitGroup(tokenizer);\n    tokenizer.eat(RIGHTSQUAREBRACKET);\n\n    result.explicit = true;\n\n    if (tokenizer.charCode() === EXCLAMATIONMARK) {\n        tokenizer.pos++;\n        result.disallowEmpty = true;\n    }\n\n    return result;\n}\n\nfunction peek(tokenizer) {\n    var code = tokenizer.charCode();\n\n    if (code < 128 && NAME_CHAR[code] === 1) {\n        return readKeywordOrFunction(tokenizer);\n    }\n\n    switch (code) {\n        case RIGHTSQUAREBRACKET:\n            // don't eat, stop scan a group\n            break;\n\n        case LEFTSQUAREBRACKET:\n            return maybeMultiplied(tokenizer, readGroup(tokenizer));\n\n        case LESSTHANSIGN:\n            return tokenizer.nextCharCode() === APOSTROPHE\n                ? readProperty(tokenizer)\n                : readType(tokenizer);\n\n        case VERTICALLINE:\n            return {\n                type: 'Combinator',\n                value: tokenizer.substringToPos(\n                    tokenizer.nextCharCode() === VERTICALLINE\n                        ? tokenizer.pos + 2\n                        : tokenizer.pos + 1\n                )\n            };\n\n        case AMPERSAND:\n            tokenizer.pos++;\n            tokenizer.eat(AMPERSAND);\n\n            return {\n                type: 'Combinator',\n                value: '&&'\n            };\n\n        case COMMA:\n            tokenizer.pos++;\n            return {\n                type: 'Comma'\n            };\n\n        case APOSTROPHE:\n            return maybeMultiplied(tokenizer, {\n                type: 'String',\n                value: scanString(tokenizer)\n            });\n\n        case SPACE:\n        case TAB:\n        case N:\n        case R:\n        case F:\n            return {\n                type: 'Spaces',\n                value: scanSpaces(tokenizer)\n            };\n\n        case COMMERCIALAT:\n            code = tokenizer.nextCharCode();\n\n            if (code < 128 && NAME_CHAR[code] === 1) {\n                tokenizer.pos++;\n                return {\n                    type: 'AtKeyword',\n                    name: scanWord(tokenizer)\n                };\n            }\n\n            return maybeToken(tokenizer);\n\n        case ASTERISK:\n        case PLUSSIGN:\n        case QUESTIONMARK:\n        case NUMBERSIGN:\n        case EXCLAMATIONMARK:\n            // prohibited tokens (used as a multiplier start)\n            break;\n\n        case LEFTCURLYBRACKET:\n            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting\n            // check next char isn't a number, because it's likely a disjoined multiplier\n            code = tokenizer.nextCharCode();\n\n            if (code < 48 || code > 57) {\n                return maybeToken(tokenizer);\n            }\n\n            break;\n\n        default:\n            return maybeToken(tokenizer);\n    }\n}\n\nfunction parse(source) {\n    var tokenizer = new Tokenizer(source);\n    var result = readImplicitGroup(tokenizer);\n\n    if (tokenizer.pos !== source.length) {\n        tokenizer.error('Unexpected input');\n    }\n\n    // reduce redundant groups with single group term\n    if (result.terms.length === 1 && result.terms[0].type === 'Group') {\n        result = result.terms[0];\n    }\n\n    return result;\n}\n\n// warm up parse to elimitate code branches that never execute\n// fix soft deoptimizations (insufficient type feedback)\nparse('[a&&<b>#|<\\'c\\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');\n\nmodule.exports = parse;\n"]},"metadata":{},"sourceType":"script"}