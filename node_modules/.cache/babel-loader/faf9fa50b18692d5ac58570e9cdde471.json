{"ast":null,"code":"var charCodeDef = require('./char-code-definitions');\n\nvar isDigit = charCodeDef.isDigit;\nvar isHexDigit = charCodeDef.isHexDigit;\nvar isUppercaseLetter = charCodeDef.isUppercaseLetter;\nvar isName = charCodeDef.isName;\nvar isWhiteSpace = charCodeDef.isWhiteSpace;\nvar isValidEscape = charCodeDef.isValidEscape;\n\nfunction getCharCode(source, offset) {\n  return offset < source.length ? source.charCodeAt(offset) : 0;\n}\n\nfunction getNewlineLength(source, offset, code) {\n  if (code === 13\n  /* \\r */\n  && getCharCode(source, offset + 1) === 10\n  /* \\n */\n  ) {\n    return 2;\n  }\n\n  return 1;\n}\n\nfunction cmpChar(testStr, offset, referenceCode) {\n  var code = testStr.charCodeAt(offset); // code.toLowerCase() for A..Z\n\n  if (isUppercaseLetter(code)) {\n    code = code | 32;\n  }\n\n  return code === referenceCode;\n}\n\nfunction cmpStr(testStr, start, end, referenceStr) {\n  if (end - start !== referenceStr.length) {\n    return false;\n  }\n\n  if (start < 0 || end > testStr.length) {\n    return false;\n  }\n\n  for (var i = start; i < end; i++) {\n    var testCode = testStr.charCodeAt(i);\n    var referenceCode = referenceStr.charCodeAt(i - start); // testCode.toLowerCase() for A..Z\n\n    if (isUppercaseLetter(testCode)) {\n      testCode = testCode | 32;\n    }\n\n    if (testCode !== referenceCode) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction findWhiteSpaceStart(source, offset) {\n  for (; offset >= 0; offset--) {\n    if (!isWhiteSpace(source.charCodeAt(offset))) {\n      break;\n    }\n  }\n\n  return offset + 1;\n}\n\nfunction findWhiteSpaceEnd(source, offset) {\n  for (; offset < source.length; offset++) {\n    if (!isWhiteSpace(source.charCodeAt(offset))) {\n      break;\n    }\n  }\n\n  return offset;\n}\n\nfunction findDecimalNumberEnd(source, offset) {\n  for (; offset < source.length; offset++) {\n    if (!isDigit(source.charCodeAt(offset))) {\n      break;\n    }\n  }\n\n  return offset;\n} // § 4.3.7. Consume an escaped code point\n\n\nfunction consumeEscaped(source, offset) {\n  // It assumes that the U+005C REVERSE SOLIDUS (\\) has already been consumed and\n  // that the next input code point has already been verified to be part of a valid escape.\n  offset += 2; // hex digit\n\n  if (isHexDigit(getCharCode(source, offset - 1))) {\n    // Consume as many hex digits as possible, but no more than 5.\n    // Note that this means 1-6 hex digits have been consumed in total.\n    for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {\n      if (!isHexDigit(getCharCode(source, offset))) {\n        break;\n      }\n    } // If the next input code point is whitespace, consume it as well.\n\n\n    var code = getCharCode(source, offset);\n\n    if (isWhiteSpace(code)) {\n      offset += getNewlineLength(source, offset, code);\n    }\n  }\n\n  return offset;\n} // §4.3.11. Consume a name\n// Note: This algorithm does not do the verification of the first few code points that are necessary\n// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,\n// ensure that the stream starts with an identifier before calling this algorithm.\n\n\nfunction consumeName(source, offset) {\n  // Let result initially be an empty string.\n  // Repeatedly consume the next input code point from the stream:\n  for (; offset < source.length; offset++) {\n    var code = source.charCodeAt(offset); // name code point\n\n    if (isName(code)) {\n      // Append the code point to result.\n      continue;\n    } // the stream starts with a valid escape\n\n\n    if (isValidEscape(code, getCharCode(source, offset + 1))) {\n      // Consume an escaped code point. Append the returned code point to result.\n      offset = consumeEscaped(source, offset) - 1;\n      continue;\n    } // anything else\n    // Reconsume the current input code point. Return result.\n\n\n    break;\n  }\n\n  return offset;\n} // §4.3.12. Consume a number\n\n\nfunction consumeNumber(source, offset) {\n  var code = source.charCodeAt(offset); // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),\n  // consume it and append it to repr.\n\n  if (code === 0x002B || code === 0x002D) {\n    code = source.charCodeAt(offset += 1);\n  } // 3. While the next input code point is a digit, consume it and append it to repr.\n\n\n  if (isDigit(code)) {\n    offset = findDecimalNumberEnd(source, offset + 1);\n    code = source.charCodeAt(offset);\n  } // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:\n\n\n  if (code === 0x002E && isDigit(source.charCodeAt(offset + 1))) {\n    // 4.1 Consume them.\n    // 4.2 Append them to repr.\n    code = source.charCodeAt(offset += 2); // 4.3 Set type to \"number\".\n    // TODO\n    // 4.4 While the next input code point is a digit, consume it and append it to repr.\n\n    offset = findDecimalNumberEnd(source, offset);\n  } // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)\n  // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:\n\n\n  if (cmpChar(source, offset, 101\n  /* e */\n  )) {\n    var sign = 0;\n    code = source.charCodeAt(offset + 1); // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...\n\n    if (code === 0x002D || code === 0x002B) {\n      sign = 1;\n      code = source.charCodeAt(offset + 2);\n    } // ... followed by a digit\n\n\n    if (isDigit(code)) {\n      // 5.1 Consume them.\n      // 5.2 Append them to repr.\n      // 5.3 Set type to \"number\".\n      // TODO\n      // 5.4 While the next input code point is a digit, consume it and append it to repr.\n      offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);\n    }\n  }\n\n  return offset;\n} // § 4.3.14. Consume the remnants of a bad url\n// ... its sole use is to consume enough of the input stream to reach a recovery point\n// where normal tokenizing can resume.\n\n\nfunction consumeBadUrlRemnants(source, offset) {\n  // Repeatedly consume the next input code point from the stream:\n  for (; offset < source.length; offset++) {\n    var code = source.charCodeAt(offset); // U+0029 RIGHT PARENTHESIS ())\n    // EOF\n\n    if (code === 0x0029) {\n      // Return.\n      offset++;\n      break;\n    }\n\n    if (isValidEscape(code, getCharCode(source, offset + 1))) {\n      // Consume an escaped code point.\n      // Note: This allows an escaped right parenthesis (\"\\)\") to be encountered\n      // without ending the <bad-url-token>. This is otherwise identical to\n      // the \"anything else\" clause.\n      offset = consumeEscaped(source, offset);\n    }\n  }\n\n  return offset;\n}\n\nmodule.exports = {\n  consumeEscaped: consumeEscaped,\n  consumeName: consumeName,\n  consumeNumber: consumeNumber,\n  consumeBadUrlRemnants: consumeBadUrlRemnants,\n  cmpChar: cmpChar,\n  cmpStr: cmpStr,\n  getNewlineLength: getNewlineLength,\n  findWhiteSpaceStart: findWhiteSpaceStart,\n  findWhiteSpaceEnd: findWhiteSpaceEnd\n};","map":{"version":3,"sources":["/Users/macbook/Documents/GitHub/React 3/billing-app/node_modules/react-pdf-html/node_modules/css-tree/lib/tokenizer/utils.js"],"names":["charCodeDef","require","isDigit","isHexDigit","isUppercaseLetter","isName","isWhiteSpace","isValidEscape","getCharCode","source","offset","length","charCodeAt","getNewlineLength","code","cmpChar","testStr","referenceCode","cmpStr","start","end","referenceStr","i","testCode","findWhiteSpaceStart","findWhiteSpaceEnd","findDecimalNumberEnd","consumeEscaped","maxOffset","Math","min","consumeName","consumeNumber","sign","consumeBadUrlRemnants","module","exports"],"mappings":"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","sourcesContent":["var charCodeDef = require('./char-code-definitions');\nvar isDigit = charCodeDef.isDigit;\nvar isHexDigit = charCodeDef.isHexDigit;\nvar isUppercaseLetter = charCodeDef.isUppercaseLetter;\nvar isName = charCodeDef.isName;\nvar isWhiteSpace = charCodeDef.isWhiteSpace;\nvar isValidEscape = charCodeDef.isValidEscape;\n\nfunction getCharCode(source, offset) {\n    return offset < source.length ? source.charCodeAt(offset) : 0;\n}\n\nfunction getNewlineLength(source, offset, code) {\n    if (code === 13 /* \\r */ && getCharCode(source, offset + 1) === 10 /* \\n */) {\n        return 2;\n    }\n\n    return 1;\n}\n\nfunction cmpChar(testStr, offset, referenceCode) {\n    var code = testStr.charCodeAt(offset);\n\n    // code.toLowerCase() for A..Z\n    if (isUppercaseLetter(code)) {\n        code = code | 32;\n    }\n\n    return code === referenceCode;\n}\n\nfunction cmpStr(testStr, start, end, referenceStr) {\n    if (end - start !== referenceStr.length) {\n        return false;\n    }\n\n    if (start < 0 || end > testStr.length) {\n        return false;\n    }\n\n    for (var i = start; i < end; i++) {\n        var testCode = testStr.charCodeAt(i);\n        var referenceCode = referenceStr.charCodeAt(i - start);\n\n        // testCode.toLowerCase() for A..Z\n        if (isUppercaseLetter(testCode)) {\n            testCode = testCode | 32;\n        }\n\n        if (testCode !== referenceCode) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction findWhiteSpaceStart(source, offset) {\n    for (; offset >= 0; offset--) {\n        if (!isWhiteSpace(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset + 1;\n}\n\nfunction findWhiteSpaceEnd(source, offset) {\n    for (; offset < source.length; offset++) {\n        if (!isWhiteSpace(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset;\n}\n\nfunction findDecimalNumberEnd(source, offset) {\n    for (; offset < source.length; offset++) {\n        if (!isDigit(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset;\n}\n\n// § 4.3.7. Consume an escaped code point\nfunction consumeEscaped(source, offset) {\n    // It assumes that the U+005C REVERSE SOLIDUS (\\) has already been consumed and\n    // that the next input code point has already been verified to be part of a valid escape.\n    offset += 2;\n\n    // hex digit\n    if (isHexDigit(getCharCode(source, offset - 1))) {\n        // Consume as many hex digits as possible, but no more than 5.\n        // Note that this means 1-6 hex digits have been consumed in total.\n        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {\n            if (!isHexDigit(getCharCode(source, offset))) {\n                break;\n            }\n        }\n\n        // If the next input code point is whitespace, consume it as well.\n        var code = getCharCode(source, offset);\n        if (isWhiteSpace(code)) {\n            offset += getNewlineLength(source, offset, code);\n        }\n    }\n\n    return offset;\n}\n\n// §4.3.11. Consume a name\n// Note: This algorithm does not do the verification of the first few code points that are necessary\n// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,\n// ensure that the stream starts with an identifier before calling this algorithm.\nfunction consumeName(source, offset) {\n    // Let result initially be an empty string.\n    // Repeatedly consume the next input code point from the stream:\n    for (; offset < source.length; offset++) {\n        var code = source.charCodeAt(offset);\n\n        // name code point\n        if (isName(code)) {\n            // Append the code point to result.\n            continue;\n        }\n\n        // the stream starts with a valid escape\n        if (isValidEscape(code, getCharCode(source, offset + 1))) {\n            // Consume an escaped code point. Append the returned code point to result.\n            offset = consumeEscaped(source, offset) - 1;\n            continue;\n        }\n\n        // anything else\n        // Reconsume the current input code point. Return result.\n        break;\n    }\n\n    return offset;\n}\n\n// §4.3.12. Consume a number\nfunction consumeNumber(source, offset) {\n    var code = source.charCodeAt(offset);\n\n    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),\n    // consume it and append it to repr.\n    if (code === 0x002B || code === 0x002D) {\n        code = source.charCodeAt(offset += 1);\n    }\n\n    // 3. While the next input code point is a digit, consume it and append it to repr.\n    if (isDigit(code)) {\n        offset = findDecimalNumberEnd(source, offset + 1);\n        code = source.charCodeAt(offset);\n    }\n\n    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:\n    if (code === 0x002E && isDigit(source.charCodeAt(offset + 1))) {\n        // 4.1 Consume them.\n        // 4.2 Append them to repr.\n        code = source.charCodeAt(offset += 2);\n\n        // 4.3 Set type to \"number\".\n        // TODO\n\n        // 4.4 While the next input code point is a digit, consume it and append it to repr.\n\n        offset = findDecimalNumberEnd(source, offset);\n    }\n\n    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)\n    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:\n    if (cmpChar(source, offset, 101 /* e */)) {\n        var sign = 0;\n        code = source.charCodeAt(offset + 1);\n\n        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...\n        if (code === 0x002D || code === 0x002B) {\n            sign = 1;\n            code = source.charCodeAt(offset + 2);\n        }\n\n        // ... followed by a digit\n        if (isDigit(code)) {\n            // 5.1 Consume them.\n            // 5.2 Append them to repr.\n\n            // 5.3 Set type to \"number\".\n            // TODO\n\n            // 5.4 While the next input code point is a digit, consume it and append it to repr.\n            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);\n        }\n    }\n\n    return offset;\n}\n\n// § 4.3.14. Consume the remnants of a bad url\n// ... its sole use is to consume enough of the input stream to reach a recovery point\n// where normal tokenizing can resume.\nfunction consumeBadUrlRemnants(source, offset) {\n    // Repeatedly consume the next input code point from the stream:\n    for (; offset < source.length; offset++) {\n        var code = source.charCodeAt(offset);\n\n        // U+0029 RIGHT PARENTHESIS ())\n        // EOF\n        if (code === 0x0029) {\n            // Return.\n            offset++;\n            break;\n        }\n\n        if (isValidEscape(code, getCharCode(source, offset + 1))) {\n            // Consume an escaped code point.\n            // Note: This allows an escaped right parenthesis (\"\\)\") to be encountered\n            // without ending the <bad-url-token>. This is otherwise identical to\n            // the \"anything else\" clause.\n            offset = consumeEscaped(source, offset);\n        }\n    }\n\n    return offset;\n}\n\nmodule.exports = {\n    consumeEscaped: consumeEscaped,\n    consumeName: consumeName,\n    consumeNumber: consumeNumber,\n    consumeBadUrlRemnants: consumeBadUrlRemnants,\n\n    cmpChar: cmpChar,\n    cmpStr: cmpStr,\n\n    getNewlineLength: getNewlineLength,\n    findWhiteSpaceStart: findWhiteSpaceStart,\n    findWhiteSpaceEnd: findWhiteSpaceEnd\n};\n"]},"metadata":{},"sourceType":"script"}