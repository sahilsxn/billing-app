{"ast":null,"code":"var TYPE = require('../../tokenizer').TYPE;\n\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\nvar IDENT = TYPE.Ident;\nvar FUNCTION = TYPE.Function;\nvar COLON = TYPE.Colon;\nvar LEFTPARENTHESIS = TYPE.LeftParenthesis;\n\nfunction consumeRaw() {\n  return this.createSingleNodeList(this.Raw(this.scanner.tokenIndex, null, false));\n}\n\nfunction parentheses() {\n  this.scanner.skipSC();\n\n  if (this.scanner.tokenType === IDENT && this.lookupNonWSType(1) === COLON) {\n    return this.createSingleNodeList(this.Declaration());\n  }\n\n  return readSequence.call(this);\n}\n\nfunction readSequence() {\n  var children = this.createList();\n  var space = null;\n  var child;\n  this.scanner.skipSC();\n\n  scan: while (!this.scanner.eof) {\n    switch (this.scanner.tokenType) {\n      case WHITESPACE:\n        space = this.WhiteSpace();\n        continue;\n\n      case COMMENT:\n        this.scanner.next();\n        continue;\n\n      case FUNCTION:\n        child = this.Function(consumeRaw, this.scope.AtrulePrelude);\n        break;\n\n      case IDENT:\n        child = this.Identifier();\n        break;\n\n      case LEFTPARENTHESIS:\n        child = this.Parentheses(parentheses, this.scope.AtrulePrelude);\n        break;\n\n      default:\n        break scan;\n    }\n\n    if (space !== null) {\n      children.push(space);\n      space = null;\n    }\n\n    children.push(child);\n  }\n\n  return children;\n}\n\nmodule.exports = {\n  parse: {\n    prelude: function () {\n      var children = readSequence.call(this);\n\n      if (this.getFirstListNode(children) === null) {\n        this.error('Condition is expected');\n      }\n\n      return children;\n    },\n    block: function () {\n      return this.Block(false);\n    }\n  }\n};","map":{"version":3,"sources":["/Users/macbook/Documents/GitHub/React 3/billing-app/node_modules/react-pdf-html/node_modules/css-tree/lib/syntax/atrule/supports.js"],"names":["TYPE","require","WHITESPACE","WhiteSpace","COMMENT","Comment","IDENT","Ident","FUNCTION","Function","COLON","Colon","LEFTPARENTHESIS","LeftParenthesis","consumeRaw","createSingleNodeList","Raw","scanner","tokenIndex","parentheses","skipSC","tokenType","lookupNonWSType","Declaration","readSequence","call","children","createList","space","child","scan","eof","next","scope","AtrulePrelude","Identifier","Parentheses","push","module","exports","parse","prelude","getFirstListNode","error","block","Block"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,OAAO,CAAC,iBAAD,CAAP,CAA2BD,IAAtC;;AAEA,IAAIE,UAAU,GAAGF,IAAI,CAACG,UAAtB;AACA,IAAIC,OAAO,GAAGJ,IAAI,CAACK,OAAnB;AACA,IAAIC,KAAK,GAAGN,IAAI,CAACO,KAAjB;AACA,IAAIC,QAAQ,GAAGR,IAAI,CAACS,QAApB;AACA,IAAIC,KAAK,GAAGV,IAAI,CAACW,KAAjB;AACA,IAAIC,eAAe,GAAGZ,IAAI,CAACa,eAA3B;;AAEA,SAASC,UAAT,GAAsB;AAClB,SAAO,KAAKC,oBAAL,CACH,KAAKC,GAAL,CAAS,KAAKC,OAAL,CAAaC,UAAtB,EAAkC,IAAlC,EAAwC,KAAxC,CADG,CAAP;AAGH;;AAED,SAASC,WAAT,GAAuB;AACnB,OAAKF,OAAL,CAAaG,MAAb;;AAEA,MAAI,KAAKH,OAAL,CAAaI,SAAb,KAA2Bf,KAA3B,IACA,KAAKgB,eAAL,CAAqB,CAArB,MAA4BZ,KADhC,EACuC;AACnC,WAAO,KAAKK,oBAAL,CACH,KAAKQ,WAAL,EADG,CAAP;AAGH;;AAED,SAAOC,YAAY,CAACC,IAAb,CAAkB,IAAlB,CAAP;AACH;;AAED,SAASD,YAAT,GAAwB;AACpB,MAAIE,QAAQ,GAAG,KAAKC,UAAL,EAAf;AACA,MAAIC,KAAK,GAAG,IAAZ;AACA,MAAIC,KAAJ;AAEA,OAAKZ,OAAL,CAAaG,MAAb;;AAEAU,EAAAA,IAAI,EACJ,OAAO,CAAC,KAAKb,OAAL,CAAac,GAArB,EAA0B;AACtB,YAAQ,KAAKd,OAAL,CAAaI,SAArB;AACI,WAAKnB,UAAL;AACI0B,QAAAA,KAAK,GAAG,KAAKzB,UAAL,EAAR;AACA;;AAEJ,WAAKC,OAAL;AACI,aAAKa,OAAL,CAAae,IAAb;AACA;;AAEJ,WAAKxB,QAAL;AACIqB,QAAAA,KAAK,GAAG,KAAKpB,QAAL,CAAcK,UAAd,EAA0B,KAAKmB,KAAL,CAAWC,aAArC,CAAR;AACA;;AAEJ,WAAK5B,KAAL;AACIuB,QAAAA,KAAK,GAAG,KAAKM,UAAL,EAAR;AACA;;AAEJ,WAAKvB,eAAL;AACIiB,QAAAA,KAAK,GAAG,KAAKO,WAAL,CAAiBjB,WAAjB,EAA8B,KAAKc,KAAL,CAAWC,aAAzC,CAAR;AACA;;AAEJ;AACI,cAAMJ,IAAN;AAtBR;;AAyBA,QAAIF,KAAK,KAAK,IAAd,EAAoB;AAChBF,MAAAA,QAAQ,CAACW,IAAT,CAAcT,KAAd;AACAA,MAAAA,KAAK,GAAG,IAAR;AACH;;AAEDF,IAAAA,QAAQ,CAACW,IAAT,CAAcR,KAAd;AACH;;AAED,SAAOH,QAAP;AACH;;AAEDY,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,KAAK,EAAE;AACHC,IAAAA,OAAO,EAAE,YAAW;AAChB,UAAIf,QAAQ,GAAGF,YAAY,CAACC,IAAb,CAAkB,IAAlB,CAAf;;AAEA,UAAI,KAAKiB,gBAAL,CAAsBhB,QAAtB,MAAoC,IAAxC,EAA8C;AAC1C,aAAKiB,KAAL,CAAW,uBAAX;AACH;;AAED,aAAOjB,QAAP;AACH,KATE;AAUHkB,IAAAA,KAAK,EAAE,YAAW;AACd,aAAO,KAAKC,KAAL,CAAW,KAAX,CAAP;AACH;AAZE;AADM,CAAjB","sourcesContent":["var TYPE = require('../../tokenizer').TYPE;\n\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\nvar IDENT = TYPE.Ident;\nvar FUNCTION = TYPE.Function;\nvar COLON = TYPE.Colon;\nvar LEFTPARENTHESIS = TYPE.LeftParenthesis;\n\nfunction consumeRaw() {\n    return this.createSingleNodeList(\n        this.Raw(this.scanner.tokenIndex, null, false)\n    );\n}\n\nfunction parentheses() {\n    this.scanner.skipSC();\n\n    if (this.scanner.tokenType === IDENT &&\n        this.lookupNonWSType(1) === COLON) {\n        return this.createSingleNodeList(\n            this.Declaration()\n        );\n    }\n\n    return readSequence.call(this);\n}\n\nfunction readSequence() {\n    var children = this.createList();\n    var space = null;\n    var child;\n\n    this.scanner.skipSC();\n\n    scan:\n    while (!this.scanner.eof) {\n        switch (this.scanner.tokenType) {\n            case WHITESPACE:\n                space = this.WhiteSpace();\n                continue;\n\n            case COMMENT:\n                this.scanner.next();\n                continue;\n\n            case FUNCTION:\n                child = this.Function(consumeRaw, this.scope.AtrulePrelude);\n                break;\n\n            case IDENT:\n                child = this.Identifier();\n                break;\n\n            case LEFTPARENTHESIS:\n                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);\n                break;\n\n            default:\n                break scan;\n        }\n\n        if (space !== null) {\n            children.push(space);\n            space = null;\n        }\n\n        children.push(child);\n    }\n\n    return children;\n}\n\nmodule.exports = {\n    parse: {\n        prelude: function() {\n            var children = readSequence.call(this);\n\n            if (this.getFirstListNode(children) === null) {\n                this.error('Condition is expected');\n            }\n\n            return children;\n        },\n        block: function() {\n            return this.Block(false);\n        }\n    }\n};\n"]},"metadata":{},"sourceType":"script"}