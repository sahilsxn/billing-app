{"ast":null,"code":"import he from 'he';\nimport { selectAll, selectOne } from 'css-select';\nimport Node from './node';\nimport NodeType from './type';\nimport TextNode from './text';\nimport Matcher from '../matcher';\nimport arr_back from '../back';\nimport CommentNode from './comment'; // const { decode } = he;\n\nfunction decode(val) {\n  // clone string\n  return JSON.parse(JSON.stringify(he.decode(val)));\n} // https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\n\n\nconst kBlockElements = new Set();\nkBlockElements.add('address');\nkBlockElements.add('ADDRESS');\nkBlockElements.add('article');\nkBlockElements.add('ARTICLE');\nkBlockElements.add('aside');\nkBlockElements.add('ASIDE');\nkBlockElements.add('blockquote');\nkBlockElements.add('BLOCKQUOTE');\nkBlockElements.add('br');\nkBlockElements.add('BR');\nkBlockElements.add('details');\nkBlockElements.add('DETAILS');\nkBlockElements.add('dialog');\nkBlockElements.add('DIALOG');\nkBlockElements.add('dd');\nkBlockElements.add('DD');\nkBlockElements.add('div');\nkBlockElements.add('DIV');\nkBlockElements.add('dl');\nkBlockElements.add('DL');\nkBlockElements.add('dt');\nkBlockElements.add('DT');\nkBlockElements.add('fieldset');\nkBlockElements.add('FIELDSET');\nkBlockElements.add('figcaption');\nkBlockElements.add('FIGCAPTION');\nkBlockElements.add('figure');\nkBlockElements.add('FIGURE');\nkBlockElements.add('footer');\nkBlockElements.add('FOOTER');\nkBlockElements.add('form');\nkBlockElements.add('FORM');\nkBlockElements.add('h1');\nkBlockElements.add('H1');\nkBlockElements.add('h2');\nkBlockElements.add('H2');\nkBlockElements.add('h3');\nkBlockElements.add('H3');\nkBlockElements.add('h4');\nkBlockElements.add('H4');\nkBlockElements.add('h5');\nkBlockElements.add('H5');\nkBlockElements.add('h6');\nkBlockElements.add('H6');\nkBlockElements.add('header');\nkBlockElements.add('HEADER');\nkBlockElements.add('hgroup');\nkBlockElements.add('HGROUP');\nkBlockElements.add('hr');\nkBlockElements.add('HR');\nkBlockElements.add('li');\nkBlockElements.add('LI');\nkBlockElements.add('main');\nkBlockElements.add('MAIN');\nkBlockElements.add('nav');\nkBlockElements.add('NAV');\nkBlockElements.add('ol');\nkBlockElements.add('OL');\nkBlockElements.add('p');\nkBlockElements.add('P');\nkBlockElements.add('pre');\nkBlockElements.add('PRE');\nkBlockElements.add('section');\nkBlockElements.add('SECTION');\nkBlockElements.add('table');\nkBlockElements.add('TABLE');\nkBlockElements.add('td');\nkBlockElements.add('TD');\nkBlockElements.add('tr');\nkBlockElements.add('TR');\nkBlockElements.add('ul');\nkBlockElements.add('UL');\n\nclass DOMTokenList {\n  constructor() {\n    let valuesInit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let afterUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => null;\n    this._set = new Set(valuesInit);\n    this._afterUpdate = afterUpdate;\n  }\n\n  _validate(c) {\n    if (/\\s/.test(c)) {\n      throw new Error(`DOMException in DOMTokenList.add: The token '${c}' contains HTML space characters, which are not valid in tokens.`);\n    }\n  }\n\n  add(c) {\n    this._validate(c);\n\n    this._set.add(c);\n\n    this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n\n  }\n\n  replace(c1, c2) {\n    this._validate(c2);\n\n    this._set.delete(c1);\n\n    this._set.add(c2);\n\n    this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n\n  }\n\n  remove(c) {\n    this._set.delete(c) && this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n  }\n\n  toggle(c) {\n    this._validate(c);\n\n    if (this._set.has(c)) this._set.delete(c);else this._set.add(c);\n\n    this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n\n  }\n\n  contains(c) {\n    return this._set.has(c);\n  }\n\n  get length() {\n    return this._set.size;\n  }\n\n  values() {\n    return this._set.values();\n  }\n\n  get value() {\n    return Array.from(this._set.values());\n  }\n\n  toString() {\n    return Array.from(this._set.values()).join(' ');\n  }\n\n}\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree\n *   structure provided (no parentNode, nextSibling,\n *   previousSibling etc).\n * @class HTMLElement\n * @extends {Node}\n */\n\n\nexport default class HTMLElement extends Node {\n  /**\n   * Creates an instance of HTMLElement.\n   * @param keyAttrs\tid and class attribute\n   * @param [rawAttrs]\tattributes in string\n   *\n   * @memberof HTMLElement\n   */\n  constructor(tagName, keyAttrs) {\n    let rawAttrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let parentNode = arguments.length > 3 ? arguments[3] : undefined;\n    super(parentNode);\n    this.rawAttrs = rawAttrs;\n    /**\n     * Node Type declaration.\n     */\n\n    this.nodeType = NodeType.ELEMENT_NODE;\n    this.rawTagName = tagName;\n    this.rawAttrs = rawAttrs || '';\n    this.id = keyAttrs.id || '';\n    this.childNodes = [];\n    this.classList = new DOMTokenList(keyAttrs.class ? keyAttrs.class.split(/\\s+/) : [], classList => this.setAttribute('class', classList.toString()) // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n    );\n\n    if (keyAttrs.id) {\n      if (!rawAttrs) {\n        this.rawAttrs = `id=\"${keyAttrs.id}\"`;\n      }\n    }\n\n    if (keyAttrs.class) {\n      if (!rawAttrs) {\n        const cls = `class=\"${this.classList.toString()}\"`;\n\n        if (this.rawAttrs) {\n          this.rawAttrs += ` ${cls}`;\n        } else {\n          this.rawAttrs = cls;\n        }\n      }\n    }\n  }\n  /**\n   * Quote attribute values\n   * @param attr attribute value\n   * @returns {string} quoted value\n   */\n\n\n  quoteAttribute(attr) {\n    if (attr === null) {\n      return \"null\";\n    }\n\n    return JSON.stringify(attr.replace(/\"/g, '&quot;'));\n  }\n  /**\n   * Remove current element\n   */\n\n\n  remove() {\n    if (this.parentNode) {\n      const children = this.parentNode.childNodes;\n      this.parentNode.childNodes = children.filter(child => {\n        return this !== child;\n      });\n    }\n  }\n  /**\n   * Remove Child element from childNodes array\n   * @param {HTMLElement} node     node to remove\n   */\n\n\n  removeChild(node) {\n    this.childNodes = this.childNodes.filter(child => {\n      return child !== node;\n    });\n  }\n  /**\n   * Exchanges given child with new child\n   * @param {HTMLElement} oldNode     node to exchange\n   * @param {HTMLElement} newNode     new node\n   */\n\n\n  exchangeChild(oldNode, newNode) {\n    const children = this.childNodes;\n    this.childNodes = children.map(child => {\n      if (child === oldNode) {\n        return newNode;\n      }\n\n      return child;\n    });\n  }\n\n  get tagName() {\n    return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;\n  }\n\n  get localName() {\n    return this.rawTagName.toLowerCase();\n  }\n  /**\n   * Get escpaed (as-it) text value of current node and its children.\n   * @return {string} text content\n   */\n\n\n  get rawText() {\n    return this.childNodes.reduce((pre, cur) => {\n      return pre += cur.rawText;\n    }, '');\n  }\n\n  get textContent() {\n    return this.rawText;\n  }\n\n  set textContent(val) {\n    const content = [new TextNode(val, this)];\n    this.childNodes = content;\n  }\n  /**\n   * Get unescaped text value of current node and its children.\n   * @return {string} text content\n   */\n\n\n  get text() {\n    return decode(this.rawText);\n  }\n  /**\n   * Get structured Text (with '\\n' etc.)\n   * @return {string} structured text\n   */\n\n\n  get structuredText() {\n    let currentBlock = [];\n    const blocks = [currentBlock];\n\n    function dfs(node) {\n      if (node.nodeType === NodeType.ELEMENT_NODE) {\n        if (kBlockElements.has(node.rawTagName)) {\n          if (currentBlock.length > 0) {\n            blocks.push(currentBlock = []);\n          }\n\n          node.childNodes.forEach(dfs);\n\n          if (currentBlock.length > 0) {\n            blocks.push(currentBlock = []);\n          }\n        } else {\n          node.childNodes.forEach(dfs);\n        }\n      } else if (node.nodeType === NodeType.TEXT_NODE) {\n        if (node.isWhitespace) {\n          // Whitespace node, postponed output\n          currentBlock.prependWhitespace = true;\n        } else {\n          let text = node.trimmedText;\n\n          if (currentBlock.prependWhitespace) {\n            text = ` ${text}`;\n            currentBlock.prependWhitespace = false;\n          }\n\n          currentBlock.push(text);\n        }\n      }\n    }\n\n    dfs(this);\n    return blocks.map(block => {\n      // Normalize each line's whitespace\n      return block.join('').replace(/\\s{2,}/g, ' ');\n    }).join('\\n').replace(/\\s+$/, ''); // trimRight;\n  }\n\n  toString() {\n    const tag = this.rawTagName;\n\n    if (tag) {\n      // const void_tags = new Set('area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr'.split('|'));\n      // const is_void = void_tags.has(tag);\n      const is_void = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/i.test(tag);\n      const attrs = this.rawAttrs ? ` ${this.rawAttrs}` : '';\n\n      if (is_void) {\n        return `<${tag}${attrs}>`;\n      }\n\n      return `<${tag}${attrs}>${this.innerHTML}</${tag}>`;\n    }\n\n    return this.innerHTML;\n  }\n\n  get innerHTML() {\n    return this.childNodes.map(child => {\n      return child.toString();\n    }).join('');\n  }\n\n  set innerHTML(content) {\n    //const r = parse(content, global.options); // TODO global.options ?\n    const r = parse(content);\n    this.childNodes = r.childNodes.length ? r.childNodes : [new TextNode(content, this)];\n  }\n\n  set_content(content) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (content instanceof Node) {\n      content = [content];\n    } else if (typeof content == 'string') {\n      const r = parse(content, options);\n      content = r.childNodes.length ? r.childNodes : [new TextNode(content, this)];\n    }\n\n    this.childNodes = content;\n  }\n\n  replaceWith() {\n    for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {\n      nodes[_key] = arguments[_key];\n    }\n\n    const content = nodes.map(node => {\n      if (node instanceof Node) {\n        return [node];\n      } else if (typeof node == 'string') {\n        // const r = parse(content, global.options); // TODO global.options ?\n        const r = parse(node);\n        return r.childNodes.length ? r.childNodes : [new TextNode(node, this)];\n      }\n\n      return [];\n    }).flat();\n    const idx = this.parentNode.childNodes.findIndex(child => {\n      return child === this;\n    });\n    this.parentNode.childNodes = [...this.parentNode.childNodes.slice(0, idx), ...content, ...this.parentNode.childNodes.slice(idx + 1)];\n  }\n\n  get outerHTML() {\n    return this.toString();\n  }\n  /**\n   * Trim element from right (in block) after seeing pattern in a TextNode.\n   * @param  {RegExp} pattern pattern to find\n   * @return {HTMLElement}    reference to current node\n   */\n\n\n  trimRight(pattern) {\n    for (let i = 0; i < this.childNodes.length; i++) {\n      const childNode = this.childNodes[i];\n\n      if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n        childNode.trimRight(pattern);\n      } else {\n        const index = childNode.rawText.search(pattern);\n\n        if (index > -1) {\n          childNode.rawText = childNode.rawText.substr(0, index); // trim all following nodes.\n\n          this.childNodes.length = i + 1;\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Get DOM structure\n   * @return {string} strucutre\n   */\n\n\n  get structure() {\n    const res = [];\n    let indention = 0;\n\n    function write(str) {\n      res.push('  '.repeat(indention) + str);\n    }\n\n    function dfs(node) {\n      const idStr = node.id ? `#${node.id}` : '';\n      const classStr = node.classList.length ? `.${node.classList.value.join('.')}` : ''; // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-unsafe-call\n\n      write(`${node.rawTagName}${idStr}${classStr}`);\n      indention++;\n      node.childNodes.forEach(childNode => {\n        if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n          dfs(childNode);\n        } else if (childNode.nodeType === NodeType.TEXT_NODE) {\n          if (!childNode.isWhitespace) {\n            write('#text');\n          }\n        }\n      });\n      indention--;\n    }\n\n    dfs(this);\n    return res.join('\\n');\n  }\n  /**\n   * Remove whitespaces in this sub tree.\n   * @return {HTMLElement} pointer to this\n   */\n\n\n  removeWhitespace() {\n    let o = 0;\n    this.childNodes.forEach(node => {\n      if (node.nodeType === NodeType.TEXT_NODE) {\n        if (node.isWhitespace) {\n          return;\n        }\n\n        node.rawText = node.trimmedText;\n      } else if (node.nodeType === NodeType.ELEMENT_NODE) {\n        node.removeWhitespace();\n      }\n\n      this.childNodes[o++] = node;\n    });\n    this.childNodes.length = o;\n    return this;\n  }\n  /**\n   * Query CSS selector to find matching nodes.\n   * @param  {string}         selector Simplified CSS selector\n   * @return {HTMLElement[]}  matching elements\n   */\n\n\n  querySelectorAll(selector) {\n    return selectAll(selector, this, {\n      xmlMode: true,\n      adapter: Matcher\n    }); // let matcher: Matcher;\n    // if (selector instanceof Matcher) {\n    // \tmatcher = selector;\n    // \tmatcher.reset();\n    // } else {\n    // \tif (selector.includes(',')) {\n    // \t\tconst selectors = selector.split(',');\n    // \t\treturn Array.from(selectors.reduce((pre, cur) => {\n    // \t\t\tconst result = this.querySelectorAll(cur.trim());\n    // \t\t\treturn result.reduce((p, c) => {\n    // \t\t\t\treturn p.add(c);\n    // \t\t\t}, pre);\n    // \t\t}, new Set<HTMLElement>()));\n    // \t}\n    // \tmatcher = new Matcher(selector);\n    // }\n    // interface IStack {\n    // \t0: Node;\t// node\n    // \t1: number;\t// children\n    // \t2: boolean;\t// found flag\n    // }\n    // const stack = [] as IStack[];\n    // return this.childNodes.reduce((res, cur) => {\n    // \tstack.push([cur, 0, false]);\n    // \twhile (stack.length) {\n    // \t\tconst state = arr_back(stack);\t// get last element\n    // \t\tconst el = state[0];\n    // \t\tif (state[1] === 0) {\n    // \t\t\t// Seen for first time.\n    // \t\t\tif (el.nodeType !== NodeType.ELEMENT_NODE) {\n    // \t\t\t\tstack.pop();\n    // \t\t\t\tcontinue;\n    // \t\t\t}\n    // \t\t\tconst html_el = el as HTMLElement;\n    // \t\t\tstate[2] = matcher.advance(html_el);\n    // \t\t\tif (state[2]) {\n    // \t\t\t\tif (matcher.matched) {\n    // \t\t\t\t\tres.push(html_el);\n    // \t\t\t\t\tres.push(...(html_el.querySelectorAll(selector)));\n    // \t\t\t\t\t// no need to go further.\n    // \t\t\t\t\tmatcher.rewind();\n    // \t\t\t\t\tstack.pop();\n    // \t\t\t\t\tcontinue;\n    // \t\t\t\t}\n    // \t\t\t}\n    // \t\t}\n    // \t\tif (state[1] < el.childNodes.length) {\n    // \t\t\tstack.push([el.childNodes[state[1]++], 0, false]);\n    // \t\t} else {\n    // \t\t\tif (state[2]) {\n    // \t\t\t\tmatcher.rewind();\n    // \t\t\t}\n    // \t\t\tstack.pop();\n    // \t\t}\n    // \t}\n    // \treturn res;\n    // }, [] as HTMLElement[]);\n  }\n  /**\n   * Query CSS Selector to find matching node.\n   * @param  {string}         selector Simplified CSS selector\n   * @return {HTMLElement}    matching node\n   */\n\n\n  querySelector(selector) {\n    return selectOne(selector, this, {\n      xmlMode: true,\n      adapter: Matcher\n    }); // let matcher: Matcher;\n    // if (selector instanceof Matcher) {\n    // \tmatcher = selector;\n    // \tmatcher.reset();\n    // } else {\n    // \tmatcher = new Matcher(selector);\n    // }\n    // const stack = [] as { 0: Node; 1: 0 | 1; 2: boolean }[];\n    // for (const node of this.childNodes) {\n    // \tstack.push([node, 0, false]);\n    // \twhile (stack.length) {\n    // \t\tconst state = arr_back(stack);\n    // \t\tconst el = state[0];\n    // \t\tif (state[1] === 0) {\n    // \t\t\t// Seen for first time.\n    // \t\t\tif (el.nodeType !== NodeType.ELEMENT_NODE) {\n    // \t\t\t\tstack.pop();\n    // \t\t\t\tcontinue;\n    // \t\t\t}\n    // \t\t\tstate[2] = matcher.advance(el as HTMLElement);\n    // \t\t\tif (state[2]) {\n    // \t\t\t\tif (matcher.matched) {\n    // \t\t\t\t\treturn el as HTMLElement;\n    // \t\t\t\t}\n    // \t\t\t}\n    // \t\t}\n    // \t\tif (state[1] < el.childNodes.length) {\n    // \t\t\tstack.push([el.childNodes[state[1]++], 0, false]);\n    // \t\t} else {\n    // \t\t\tif (state[2]) {\n    // \t\t\t\tmatcher.rewind();\n    // \t\t\t}\n    // \t\t\tstack.pop();\n    // \t\t}\n    // \t}\n    // }\n    // return null;\n  }\n  /**\n   * traverses the Element and its parents (heading toward the document root) until it finds a node that matches the provided selector string. Will return itself or the matching ancestor. If no such element exists, it returns null.\n   * @param selector a DOMString containing a selector list\n   */\n\n\n  closest(selector) {\n    const mapChild = new Map();\n    let el = this;\n    let old = null;\n\n    function findOne(test, elems) {\n      let elem = null;\n\n      for (let i = 0, l = elems.length; i < l && !elem; i++) {\n        const el = elems[i];\n\n        if (test(el)) {\n          elem = el;\n        } else {\n          const child = mapChild.get(el);\n\n          if (child) {\n            elem = findOne(test, [child]);\n          }\n        }\n      }\n\n      return elem;\n    }\n\n    while (el) {\n      mapChild.set(el, old);\n      old = el;\n      el = el.parentNode;\n    }\n\n    el = this;\n\n    while (el) {\n      const e = selectOne(selector, el, {\n        xmlMode: true,\n        adapter: { ...Matcher,\n\n          getChildren(node) {\n            const child = mapChild.get(node);\n            return child && [child];\n          },\n\n          getSiblings(node) {\n            return [node];\n          },\n\n          findOne,\n\n          findAll() {\n            return [];\n          }\n\n        }\n      });\n\n      if (e) {\n        return e;\n      }\n\n      el = el.parentNode;\n    }\n\n    return null;\n  }\n  /**\n   * Append a child node to childNodes\n   * @param  {Node} node node to append\n   * @return {Node}      node appended\n   */\n\n\n  appendChild(node) {\n    // node.parentNode = this;\n    this.childNodes.push(node);\n    node.parentNode = this;\n    return node;\n  }\n  /**\n   * Get first child node\n   * @return {Node} first child node\n   */\n\n\n  get firstChild() {\n    return this.childNodes[0];\n  }\n  /**\n   * Get last child node\n   * @return {Node} last child node\n   */\n\n\n  get lastChild() {\n    return arr_back(this.childNodes);\n  }\n  /**\n   * Get attributes\n   * @access private\n   * @return {Object} parsed and unescaped attributes\n   */\n\n\n  get attrs() {\n    if (this._attrs) {\n      return this._attrs;\n    }\n\n    this._attrs = {};\n    const attrs = this.rawAttributes;\n\n    for (const key in attrs) {\n      const val = attrs[key] || '';\n      this._attrs[key.toLowerCase()] = decode(val);\n    }\n\n    return this._attrs;\n  }\n\n  get attributes() {\n    const ret_attrs = {};\n    const attrs = this.rawAttributes;\n\n    for (const key in attrs) {\n      const val = attrs[key] || '';\n      ret_attrs[key] = decode(val);\n    }\n\n    return ret_attrs;\n  }\n  /**\n   * Get escaped (as-it) attributes\n   * @return {Object} parsed attributes\n   */\n\n\n  get rawAttributes() {\n    if (this._rawAttrs) {\n      return this._rawAttrs;\n    }\n\n    const attrs = {};\n\n    if (this.rawAttrs) {\n      const re = /\\b([a-z][a-z0-9-_:]*)(?:\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\S+)))?/ig;\n      let match;\n\n      while (match = re.exec(this.rawAttrs)) {\n        attrs[match[1]] = match[2] || match[3] || match[4] || null;\n      }\n    }\n\n    this._rawAttrs = attrs;\n    return attrs;\n  }\n\n  removeAttribute(key) {\n    const attrs = this.rawAttributes;\n    delete attrs[key]; // Update this.attribute\n\n    if (this._attrs) {\n      delete this._attrs[key];\n    } // Update rawString\n\n\n    this.rawAttrs = Object.keys(attrs).map(name => {\n      const val = JSON.stringify(attrs[name]);\n\n      if (val === undefined || val === 'null') {\n        return name;\n      }\n\n      return `${name}=${val}`;\n    }).join(' '); // Update this.id\n\n    if (key === 'id') {\n      this.id = '';\n    }\n  }\n\n  hasAttribute(key) {\n    return key.toLowerCase() in this.attrs;\n  }\n  /**\n   * Get an attribute\n   * @return {string} value of the attribute\n   */\n\n\n  getAttribute(key) {\n    return this.attrs[key.toLowerCase()];\n  }\n  /**\n   * Set an attribute value to the HTMLElement\n   * @param {string} key The attribute name\n   * @param {string} value The value to set, or null / undefined to remove an attribute\n   */\n\n\n  setAttribute(key, value) {\n    if (arguments.length < 2) {\n      throw new Error('Failed to execute \\'setAttribute\\' on \\'Element\\'');\n    }\n\n    const k2 = key.toLowerCase();\n    const attrs = this.rawAttributes;\n\n    for (const k in attrs) {\n      if (k.toLowerCase() === k2) {\n        key = k;\n        break;\n      }\n    }\n\n    attrs[key] = String(value); // update this.attrs\n\n    if (this._attrs) {\n      this._attrs[k2] = decode(attrs[key]);\n    } // Update rawString\n\n\n    this.rawAttrs = Object.keys(attrs).map(name => {\n      const val = this.quoteAttribute(attrs[name]);\n\n      if (val === 'null' || val === '\"\"') {\n        return name;\n      }\n\n      return `${name}=${val}`;\n    }).join(' '); // Update this.id\n\n    if (key === 'id') {\n      this.id = value;\n    }\n  }\n  /**\n   * Replace all the attributes of the HTMLElement by the provided attributes\n   * @param {Attributes} attributes the new attribute set\n   */\n\n\n  setAttributes(attributes) {\n    // Invalidate current this.attributes\n    if (this._attrs) {\n      delete this._attrs;\n    } // Invalidate current this.rawAttributes\n\n\n    if (this._rawAttrs) {\n      delete this._rawAttrs;\n    } // Update rawString\n\n\n    this.rawAttrs = Object.keys(attributes).map(name => {\n      const val = attributes[name];\n\n      if (val === 'null' || val === '\"\"') {\n        return name;\n      }\n\n      return `${name}=${this.quoteAttribute(String(val))}`;\n    }).join(' ');\n  }\n\n  insertAdjacentHTML(where, html) {\n    if (arguments.length < 2) {\n      throw new Error('2 arguments required');\n    }\n\n    const p = parse(html);\n\n    if (where === 'afterend') {\n      const idx = this.parentNode.childNodes.findIndex(child => {\n        return child === this;\n      });\n      this.parentNode.childNodes.splice(idx + 1, 0, ...p.childNodes);\n      p.childNodes.forEach(n => {\n        if (n instanceof HTMLElement) {\n          n.parentNode = this.parentNode;\n        }\n      });\n    } else if (where === 'afterbegin') {\n      this.childNodes.unshift(...p.childNodes);\n    } else if (where === 'beforeend') {\n      p.childNodes.forEach(n => {\n        this.appendChild(n);\n      });\n    } else if (where === 'beforebegin') {\n      const idx = this.parentNode.childNodes.findIndex(child => {\n        return child === this;\n      });\n      this.parentNode.childNodes.splice(idx, 0, ...p.childNodes);\n      p.childNodes.forEach(n => {\n        if (n instanceof HTMLElement) {\n          n.parentNode = this.parentNode;\n        }\n      });\n    } else {\n      throw new Error(`The value provided ('${where}') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'`);\n    } // if (!where || html === undefined || html === null) {\n    // \treturn;\n    // }\n\n  }\n\n  get nextSibling() {\n    if (this.parentNode) {\n      const children = this.parentNode.childNodes;\n      let i = 0;\n\n      while (i < children.length) {\n        const child = children[i++];\n\n        if (this === child) {\n          return children[i] || null;\n        }\n      }\n\n      return null;\n    }\n  }\n\n  get nextElementSibling() {\n    if (this.parentNode) {\n      const children = this.parentNode.childNodes;\n      let i = 0;\n      let find = false;\n\n      while (i < children.length) {\n        const child = children[i++];\n\n        if (find) {\n          if (child instanceof HTMLElement) {\n            return child || null;\n          }\n        } else if (this === child) {\n          find = true;\n        }\n      }\n\n      return null;\n    }\n  }\n\n  get classNames() {\n    return this.classList.toString();\n  }\n\n} // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\n\nconst kMarkupPattern = /<!--[^]*?(?=-->)-->|<(\\/?)([a-z][-.:0-9_a-z]*)\\s*([^>]*?)(\\/?)>/ig; // <(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\n// <([a-z][-.:0-9_a-z]*)\\s*\\/>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>|<(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\n\nconst kAttributePattern = /(^|\\s)(id|class)\\s*=\\s*(\"([^\"]*)\"|'([^']*)'|(\\S+))/ig;\nconst kSelfClosingElements = {\n  area: true,\n  AREA: true,\n  base: true,\n  BASE: true,\n  br: true,\n  BR: true,\n  col: true,\n  COL: true,\n  hr: true,\n  HR: true,\n  img: true,\n  IMG: true,\n  input: true,\n  INPUT: true,\n  link: true,\n  LINK: true,\n  meta: true,\n  META: true,\n  source: true,\n  SOURCE: true,\n  embed: true,\n  EMBED: true,\n  param: true,\n  PARAM: true,\n  track: true,\n  TRACK: true,\n  wbr: true,\n  WBR: true\n};\nconst kElementsClosedByOpening = {\n  li: {\n    li: true,\n    LI: true\n  },\n  LI: {\n    li: true,\n    LI: true\n  },\n  p: {\n    p: true,\n    div: true,\n    P: true,\n    DIV: true\n  },\n  P: {\n    p: true,\n    div: true,\n    P: true,\n    DIV: true\n  },\n  b: {\n    div: true,\n    DIV: true\n  },\n  B: {\n    div: true,\n    DIV: true\n  },\n  td: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  TD: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  th: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  TH: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  h1: {\n    h1: true,\n    H1: true\n  },\n  H1: {\n    h1: true,\n    H1: true\n  },\n  h2: {\n    h2: true,\n    H2: true\n  },\n  H2: {\n    h2: true,\n    H2: true\n  },\n  h3: {\n    h3: true,\n    H3: true\n  },\n  H3: {\n    h3: true,\n    H3: true\n  },\n  h4: {\n    h4: true,\n    H4: true\n  },\n  H4: {\n    h4: true,\n    H4: true\n  },\n  h5: {\n    h5: true,\n    H5: true\n  },\n  H5: {\n    h5: true,\n    H5: true\n  },\n  h6: {\n    h6: true,\n    H6: true\n  },\n  H6: {\n    h6: true,\n    H6: true\n  }\n};\nconst kElementsClosedByClosing = {\n  li: {\n    ul: true,\n    ol: true,\n    UL: true,\n    OL: true\n  },\n  LI: {\n    ul: true,\n    ol: true,\n    UL: true,\n    OL: true\n  },\n  a: {\n    div: true,\n    DIV: true\n  },\n  A: {\n    div: true,\n    DIV: true\n  },\n  b: {\n    div: true,\n    DIV: true\n  },\n  B: {\n    div: true,\n    DIV: true\n  },\n  i: {\n    div: true,\n    DIV: true\n  },\n  I: {\n    div: true,\n    DIV: true\n  },\n  p: {\n    div: true,\n    DIV: true\n  },\n  P: {\n    div: true,\n    DIV: true\n  },\n  td: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  TD: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  th: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  TH: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  }\n};\nconst frameflag = 'documentfragmentcontainer';\n/**\n * Parses HTML and returns a root element\n * Parse a chuck of HTML source.\n * @param  {string} data      html\n * @return {HTMLElement}      root element\n */\n\nexport function base_parse(data) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    lowerCaseTagName: false,\n    comment: false\n  };\n  const elements = options.blockTextElements || {\n    script: true,\n    noscript: true,\n    style: true,\n    pre: true\n  };\n  const element_names = Object.keys(elements);\n  const kBlockTextElements = element_names.map(it => {\n    return new RegExp(it, 'i');\n  });\n  const kIgnoreElements = element_names.filter(it => {\n    return elements[it];\n  }).map(it => {\n    return new RegExp(it, 'i');\n  });\n\n  function element_should_be_ignore(tag) {\n    return kIgnoreElements.some(it => {\n      return it.test(tag);\n    });\n  }\n\n  function is_block_text_element(tag) {\n    return kBlockTextElements.some(it => {\n      return it.test(tag);\n    });\n  }\n\n  const root = new HTMLElement(null, {}, '', null);\n  let currentParent = root;\n  const stack = [root];\n  let lastTextPos = -1;\n  let match; // https://github.com/taoqf/node-html-parser/issues/38\n\n  data = `<${frameflag}>${data}</${frameflag}>`;\n\n  while (match = kMarkupPattern.exec(data)) {\n    if (lastTextPos > -1) {\n      if (lastTextPos + match[0].length < kMarkupPattern.lastIndex) {\n        // if has content\n        const text = data.substring(lastTextPos, kMarkupPattern.lastIndex - match[0].length);\n        currentParent.appendChild(new TextNode(text, currentParent));\n      }\n    }\n\n    lastTextPos = kMarkupPattern.lastIndex;\n\n    if (match[2] === frameflag) {\n      continue;\n    }\n\n    if (match[0][1] === '!') {\n      // this is a comment\n      if (options.comment) {\n        // Only keep what is in between <!-- and -->\n        const text = data.substring(lastTextPos - 3, lastTextPos - match[0].length + 4);\n        currentParent.appendChild(new CommentNode(text, currentParent));\n      }\n\n      continue;\n    }\n\n    if (options.lowerCaseTagName) {\n      match[2] = match[2].toLowerCase();\n    }\n\n    if (!match[1]) {\n      // not </ tags\n      const attrs = {};\n\n      for (let attMatch; attMatch = kAttributePattern.exec(match[3]);) {\n        attrs[attMatch[2].toLowerCase()] = attMatch[4] || attMatch[5] || attMatch[6];\n      }\n\n      const tagName = currentParent.rawTagName;\n\n      if (!match[4] && kElementsClosedByOpening[tagName]) {\n        if (kElementsClosedByOpening[tagName][match[2]]) {\n          stack.pop();\n          currentParent = arr_back(stack);\n        }\n      } // ignore container tag we add above\n      // https://github.com/taoqf/node-html-parser/issues/38\n\n\n      currentParent = currentParent.appendChild(new HTMLElement(match[2], attrs, match[3], null));\n      stack.push(currentParent);\n\n      if (is_block_text_element(match[2])) {\n        // a little test to find next </script> or </style> ...\n        const closeMarkup = `</${match[2]}>`;\n\n        const index = (() => {\n          if (options.lowerCaseTagName) {\n            return data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex);\n          }\n\n          return data.indexOf(closeMarkup, kMarkupPattern.lastIndex);\n        })();\n\n        if (element_should_be_ignore(match[2])) {\n          let text;\n\n          if (index === -1) {\n            // there is no matching ending for the text element.\n            text = data.substr(kMarkupPattern.lastIndex);\n          } else {\n            text = data.substring(kMarkupPattern.lastIndex, index);\n          }\n\n          if (text.length > 0) {\n            currentParent.appendChild(new TextNode(text, currentParent));\n          }\n        }\n\n        if (index === -1) {\n          lastTextPos = kMarkupPattern.lastIndex = data.length + 1;\n        } else {\n          lastTextPos = kMarkupPattern.lastIndex = index + closeMarkup.length;\n          match[1] = 'true';\n        }\n      }\n    }\n\n    if (match[1] || match[4] || kSelfClosingElements[match[2]]) {\n      // </ or /> or <br> etc.\n      while (true) {\n        if (currentParent.rawTagName === match[2]) {\n          stack.pop();\n          currentParent = arr_back(stack);\n          break;\n        } else {\n          const tagName = currentParent.tagName; // Trying to close current tag, and move on\n\n          if (kElementsClosedByClosing[tagName]) {\n            if (kElementsClosedByClosing[tagName][match[2]]) {\n              stack.pop();\n              currentParent = arr_back(stack);\n              continue;\n            }\n          } // Use aggressive strategy to handle unmatching markups.\n\n\n          break;\n        }\n      }\n    }\n  }\n\n  return stack;\n}\n/**\n * Parses HTML and returns a root element\n * Parse a chuck of HTML source.\n */\n\nexport function parse(data) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    lowerCaseTagName: false,\n    comment: false\n  };\n  const stack = base_parse(data, options);\n  const [root] = stack;\n\n  while (stack.length > 1) {\n    // Handle each error elements.\n    const last = stack.pop();\n    const oneBefore = arr_back(stack);\n\n    if (last.parentNode && last.parentNode.parentNode) {\n      if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {\n        // Pair error case <h3> <h3> handle : Fixes to <h3> </h3>\n        oneBefore.removeChild(last);\n        last.childNodes.forEach(child => {\n          oneBefore.parentNode.appendChild(child);\n        });\n        stack.pop();\n      } else {\n        // Single error  <div> <h3> </div> handle: Just removes <h3>\n        oneBefore.removeChild(last);\n        last.childNodes.forEach(child => {\n          oneBefore.appendChild(child);\n        });\n      }\n    } else {// If it's final element just skip.\n    }\n  } // response.childNodes.forEach((node) => {\n  // \tif (node instanceof HTMLElement) {\n  // \t\tnode.parentNode = null;\n  // \t}\n  // });\n\n\n  return root;\n}","map":{"version":3,"sources":["/Users/macbook/Documents/GitHub/React 3/billing-app/node_modules/node-html-parser/dist/esm/nodes/html.js"],"names":["he","selectAll","selectOne","Node","NodeType","TextNode","Matcher","arr_back","CommentNode","decode","val","JSON","parse","stringify","kBlockElements","Set","add","DOMTokenList","constructor","valuesInit","afterUpdate","_set","_afterUpdate","_validate","c","test","Error","replace","c1","c2","delete","remove","toggle","has","contains","length","size","values","value","Array","from","toString","join","HTMLElement","tagName","keyAttrs","rawAttrs","parentNode","nodeType","ELEMENT_NODE","rawTagName","id","childNodes","classList","class","split","setAttribute","cls","quoteAttribute","attr","children","filter","child","removeChild","node","exchangeChild","oldNode","newNode","map","toUpperCase","localName","toLowerCase","rawText","reduce","pre","cur","textContent","content","text","structuredText","currentBlock","blocks","dfs","push","forEach","TEXT_NODE","isWhitespace","prependWhitespace","trimmedText","block","tag","is_void","attrs","innerHTML","r","set_content","options","replaceWith","nodes","flat","idx","findIndex","slice","outerHTML","trimRight","pattern","i","childNode","index","search","substr","structure","res","indention","write","str","repeat","idStr","classStr","removeWhitespace","o","querySelectorAll","selector","xmlMode","adapter","querySelector","closest","mapChild","Map","el","old","findOne","elems","elem","l","get","set","e","getChildren","getSiblings","findAll","appendChild","firstChild","lastChild","_attrs","rawAttributes","key","attributes","ret_attrs","_rawAttrs","re","match","exec","removeAttribute","Object","keys","name","undefined","hasAttribute","getAttribute","arguments","k2","k","String","setAttributes","insertAdjacentHTML","where","html","p","splice","n","unshift","nextSibling","nextElementSibling","find","classNames","kMarkupPattern","kAttributePattern","kSelfClosingElements","area","AREA","base","BASE","br","BR","col","COL","hr","HR","img","IMG","input","INPUT","link","LINK","meta","META","source","SOURCE","embed","EMBED","param","PARAM","track","TRACK","wbr","WBR","kElementsClosedByOpening","li","LI","div","P","DIV","b","B","td","th","TD","TH","h1","H1","h2","H2","h3","H3","h4","H4","h5","H5","h6","H6","kElementsClosedByClosing","ul","ol","UL","OL","a","A","I","tr","table","TR","TABLE","frameflag","base_parse","data","lowerCaseTagName","comment","elements","blockTextElements","script","noscript","style","element_names","kBlockTextElements","it","RegExp","kIgnoreElements","element_should_be_ignore","some","is_block_text_element","root","currentParent","stack","lastTextPos","lastIndex","substring","attMatch","pop","closeMarkup","toLocaleLowerCase","indexOf","last","oneBefore"],"mappings":"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,CAAChB,QAAL,KAAkB5C,QAAQ,CAACiF,SAA/B,EAA0C;AACtC,YAAIrB,IAAI,CAACsB,YAAT,EAAuB;AACnB;AACH;;AACDtB,QAAAA,IAAI,CAACQ,OAAL,GAAeR,IAAI,CAACwB,WAApB;AACH,OALD,MAMK,IAAIxB,IAAI,CAAChB,QAAL,KAAkB5C,QAAQ,CAAC6C,YAA/B,EAA6C;AAC9Ce,QAAAA,IAAI,CAACuD,gBAAL;AACH;;AACD,WAAKnE,UAAL,CAAgBoE,CAAC,EAAjB,IAAuBxD,IAAvB;AACH,KAXD;AAYA,SAAKZ,UAAL,CAAgBjB,MAAhB,GAAyBqF,CAAzB;AACA,WAAO,IAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIC,EAAAA,gBAAgB,CAACC,QAAD,EAAW;AACvB,WAAOzH,SAAS,CAACyH,QAAD,EAAW,IAAX,EAAiB;AAC7BC,MAAAA,OAAO,EAAE,IADoB;AAE7BC,MAAAA,OAAO,EAAEtH;AAFoB,KAAjB,CAAhB,CADuB,CAKvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIuH,EAAAA,aAAa,CAACH,QAAD,EAAW;AACpB,WAAOxH,SAAS,CAACwH,QAAD,EAAW,IAAX,EAAiB;AAC7BC,MAAAA,OAAO,EAAE,IADoB;AAE7BC,MAAAA,OAAO,EAAEtH;AAFoB,KAAjB,CAAhB,CADoB,CAKpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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","sourcesContent":["import he from 'he';\nimport { selectAll, selectOne } from 'css-select';\nimport Node from './node';\nimport NodeType from './type';\nimport TextNode from './text';\nimport Matcher from '../matcher';\nimport arr_back from '../back';\nimport CommentNode from './comment';\n// const { decode } = he;\nfunction decode(val) {\n    // clone string\n    return JSON.parse(JSON.stringify(he.decode(val)));\n}\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\nconst kBlockElements = new Set();\nkBlockElements.add('address');\nkBlockElements.add('ADDRESS');\nkBlockElements.add('article');\nkBlockElements.add('ARTICLE');\nkBlockElements.add('aside');\nkBlockElements.add('ASIDE');\nkBlockElements.add('blockquote');\nkBlockElements.add('BLOCKQUOTE');\nkBlockElements.add('br');\nkBlockElements.add('BR');\nkBlockElements.add('details');\nkBlockElements.add('DETAILS');\nkBlockElements.add('dialog');\nkBlockElements.add('DIALOG');\nkBlockElements.add('dd');\nkBlockElements.add('DD');\nkBlockElements.add('div');\nkBlockElements.add('DIV');\nkBlockElements.add('dl');\nkBlockElements.add('DL');\nkBlockElements.add('dt');\nkBlockElements.add('DT');\nkBlockElements.add('fieldset');\nkBlockElements.add('FIELDSET');\nkBlockElements.add('figcaption');\nkBlockElements.add('FIGCAPTION');\nkBlockElements.add('figure');\nkBlockElements.add('FIGURE');\nkBlockElements.add('footer');\nkBlockElements.add('FOOTER');\nkBlockElements.add('form');\nkBlockElements.add('FORM');\nkBlockElements.add('h1');\nkBlockElements.add('H1');\nkBlockElements.add('h2');\nkBlockElements.add('H2');\nkBlockElements.add('h3');\nkBlockElements.add('H3');\nkBlockElements.add('h4');\nkBlockElements.add('H4');\nkBlockElements.add('h5');\nkBlockElements.add('H5');\nkBlockElements.add('h6');\nkBlockElements.add('H6');\nkBlockElements.add('header');\nkBlockElements.add('HEADER');\nkBlockElements.add('hgroup');\nkBlockElements.add('HGROUP');\nkBlockElements.add('hr');\nkBlockElements.add('HR');\nkBlockElements.add('li');\nkBlockElements.add('LI');\nkBlockElements.add('main');\nkBlockElements.add('MAIN');\nkBlockElements.add('nav');\nkBlockElements.add('NAV');\nkBlockElements.add('ol');\nkBlockElements.add('OL');\nkBlockElements.add('p');\nkBlockElements.add('P');\nkBlockElements.add('pre');\nkBlockElements.add('PRE');\nkBlockElements.add('section');\nkBlockElements.add('SECTION');\nkBlockElements.add('table');\nkBlockElements.add('TABLE');\nkBlockElements.add('td');\nkBlockElements.add('TD');\nkBlockElements.add('tr');\nkBlockElements.add('TR');\nkBlockElements.add('ul');\nkBlockElements.add('UL');\nclass DOMTokenList {\n    constructor(valuesInit = [], afterUpdate = (() => null)) {\n        this._set = new Set(valuesInit);\n        this._afterUpdate = afterUpdate;\n    }\n    _validate(c) {\n        if (/\\s/.test(c)) {\n            throw new Error(`DOMException in DOMTokenList.add: The token '${c}' contains HTML space characters, which are not valid in tokens.`);\n        }\n    }\n    add(c) {\n        this._validate(c);\n        this._set.add(c);\n        this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n    }\n    replace(c1, c2) {\n        this._validate(c2);\n        this._set.delete(c1);\n        this._set.add(c2);\n        this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n    }\n    remove(c) {\n        this._set.delete(c) &&\n            this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n    }\n    toggle(c) {\n        this._validate(c);\n        if (this._set.has(c))\n            this._set.delete(c);\n        else\n            this._set.add(c);\n        this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n    }\n    contains(c) {\n        return this._set.has(c);\n    }\n    get length() {\n        return this._set.size;\n    }\n    values() {\n        return this._set.values();\n    }\n    get value() {\n        return Array.from(this._set.values());\n    }\n    toString() {\n        return Array.from(this._set.values()).join(' ');\n    }\n}\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree\n *   structure provided (no parentNode, nextSibling,\n *   previousSibling etc).\n * @class HTMLElement\n * @extends {Node}\n */\nexport default class HTMLElement extends Node {\n    /**\n     * Creates an instance of HTMLElement.\n     * @param keyAttrs\tid and class attribute\n     * @param [rawAttrs]\tattributes in string\n     *\n     * @memberof HTMLElement\n     */\n    constructor(tagName, keyAttrs, rawAttrs = '', parentNode) {\n        super(parentNode);\n        this.rawAttrs = rawAttrs;\n        /**\n         * Node Type declaration.\n         */\n        this.nodeType = NodeType.ELEMENT_NODE;\n        this.rawTagName = tagName;\n        this.rawAttrs = rawAttrs || '';\n        this.id = keyAttrs.id || '';\n        this.childNodes = [];\n        this.classList = new DOMTokenList(keyAttrs.class ? keyAttrs.class.split(/\\s+/) : [], (classList) => (this.setAttribute('class', classList.toString()) // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n        ));\n        if (keyAttrs.id) {\n            if (!rawAttrs) {\n                this.rawAttrs = `id=\"${keyAttrs.id}\"`;\n            }\n        }\n        if (keyAttrs.class) {\n            if (!rawAttrs) {\n                const cls = `class=\"${this.classList.toString()}\"`;\n                if (this.rawAttrs) {\n                    this.rawAttrs += ` ${cls}`;\n                }\n                else {\n                    this.rawAttrs = cls;\n                }\n            }\n        }\n    }\n    /**\n     * Quote attribute values\n     * @param attr attribute value\n     * @returns {string} quoted value\n     */\n    quoteAttribute(attr) {\n        if (attr === null) {\n            return \"null\";\n        }\n        return JSON.stringify(attr.replace(/\"/g, '&quot;'));\n    }\n    /**\n     * Remove current element\n     */\n    remove() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            this.parentNode.childNodes = children.filter((child) => {\n                return this !== child;\n            });\n        }\n    }\n    /**\n     * Remove Child element from childNodes array\n     * @param {HTMLElement} node     node to remove\n     */\n    removeChild(node) {\n        this.childNodes = this.childNodes.filter((child) => {\n            return (child !== node);\n        });\n    }\n    /**\n     * Exchanges given child with new child\n     * @param {HTMLElement} oldNode     node to exchange\n     * @param {HTMLElement} newNode     new node\n     */\n    exchangeChild(oldNode, newNode) {\n        const children = this.childNodes;\n        this.childNodes = children.map((child) => {\n            if (child === oldNode) {\n                return newNode;\n            }\n            return child;\n        });\n    }\n    get tagName() {\n        return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;\n    }\n    get localName() {\n        return this.rawTagName.toLowerCase();\n    }\n    /**\n     * Get escpaed (as-it) text value of current node and its children.\n     * @return {string} text content\n     */\n    get rawText() {\n        return this.childNodes.reduce((pre, cur) => {\n            return (pre += cur.rawText);\n        }, '');\n    }\n    get textContent() {\n        return this.rawText;\n    }\n    set textContent(val) {\n        const content = [new TextNode(val, this)];\n        this.childNodes = content;\n    }\n    /**\n     * Get unescaped text value of current node and its children.\n     * @return {string} text content\n     */\n    get text() {\n        return decode(this.rawText);\n    }\n    /**\n     * Get structured Text (with '\\n' etc.)\n     * @return {string} structured text\n     */\n    get structuredText() {\n        let currentBlock = [];\n        const blocks = [currentBlock];\n        function dfs(node) {\n            if (node.nodeType === NodeType.ELEMENT_NODE) {\n                if (kBlockElements.has(node.rawTagName)) {\n                    if (currentBlock.length > 0) {\n                        blocks.push(currentBlock = []);\n                    }\n                    node.childNodes.forEach(dfs);\n                    if (currentBlock.length > 0) {\n                        blocks.push(currentBlock = []);\n                    }\n                }\n                else {\n                    node.childNodes.forEach(dfs);\n                }\n            }\n            else if (node.nodeType === NodeType.TEXT_NODE) {\n                if (node.isWhitespace) {\n                    // Whitespace node, postponed output\n                    currentBlock.prependWhitespace = true;\n                }\n                else {\n                    let text = node.trimmedText;\n                    if (currentBlock.prependWhitespace) {\n                        text = ` ${text}`;\n                        currentBlock.prependWhitespace = false;\n                    }\n                    currentBlock.push(text);\n                }\n            }\n        }\n        dfs(this);\n        return blocks.map((block) => {\n            // Normalize each line's whitespace\n            return block.join('').replace(/\\s{2,}/g, ' ');\n        })\n            .join('\\n').replace(/\\s+$/, ''); // trimRight;\n    }\n    toString() {\n        const tag = this.rawTagName;\n        if (tag) {\n            // const void_tags = new Set('area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr'.split('|'));\n            // const is_void = void_tags.has(tag);\n            const is_void = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/i.test(tag);\n            const attrs = this.rawAttrs ? ` ${this.rawAttrs}` : '';\n            if (is_void) {\n                return `<${tag}${attrs}>`;\n            }\n            return `<${tag}${attrs}>${this.innerHTML}</${tag}>`;\n        }\n        return this.innerHTML;\n    }\n    get innerHTML() {\n        return this.childNodes.map((child) => {\n            return child.toString();\n        }).join('');\n    }\n    set innerHTML(content) {\n        //const r = parse(content, global.options); // TODO global.options ?\n        const r = parse(content);\n        this.childNodes = r.childNodes.length ? r.childNodes : [new TextNode(content, this)];\n    }\n    set_content(content, options = {}) {\n        if (content instanceof Node) {\n            content = [content];\n        }\n        else if (typeof content == 'string') {\n            const r = parse(content, options);\n            content = r.childNodes.length ? r.childNodes : [new TextNode(content, this)];\n        }\n        this.childNodes = content;\n    }\n    replaceWith(...nodes) {\n        const content = nodes.map((node) => {\n            if (node instanceof Node) {\n                return [node];\n            }\n            else if (typeof node == 'string') {\n                // const r = parse(content, global.options); // TODO global.options ?\n                const r = parse(node);\n                return r.childNodes.length ? r.childNodes : [new TextNode(node, this)];\n            }\n            return [];\n        }).flat();\n        const idx = this.parentNode.childNodes.findIndex((child) => {\n            return child === this;\n        });\n        this.parentNode.childNodes = [\n            ...this.parentNode.childNodes.slice(0, idx),\n            ...content,\n            ...this.parentNode.childNodes.slice(idx + 1),\n        ];\n    }\n    get outerHTML() {\n        return this.toString();\n    }\n    /**\n     * Trim element from right (in block) after seeing pattern in a TextNode.\n     * @param  {RegExp} pattern pattern to find\n     * @return {HTMLElement}    reference to current node\n     */\n    trimRight(pattern) {\n        for (let i = 0; i < this.childNodes.length; i++) {\n            const childNode = this.childNodes[i];\n            if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n                childNode.trimRight(pattern);\n            }\n            else {\n                const index = childNode.rawText.search(pattern);\n                if (index > -1) {\n                    childNode.rawText = childNode.rawText.substr(0, index);\n                    // trim all following nodes.\n                    this.childNodes.length = i + 1;\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * Get DOM structure\n     * @return {string} strucutre\n     */\n    get structure() {\n        const res = [];\n        let indention = 0;\n        function write(str) {\n            res.push('  '.repeat(indention) + str);\n        }\n        function dfs(node) {\n            const idStr = node.id ? (`#${node.id}`) : '';\n            const classStr = node.classList.length ? (`.${node.classList.value.join('.')}`) : ''; // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-unsafe-call\n            write(`${node.rawTagName}${idStr}${classStr}`);\n            indention++;\n            node.childNodes.forEach((childNode) => {\n                if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n                    dfs(childNode);\n                }\n                else if (childNode.nodeType === NodeType.TEXT_NODE) {\n                    if (!childNode.isWhitespace) {\n                        write('#text');\n                    }\n                }\n            });\n            indention--;\n        }\n        dfs(this);\n        return res.join('\\n');\n    }\n    /**\n     * Remove whitespaces in this sub tree.\n     * @return {HTMLElement} pointer to this\n     */\n    removeWhitespace() {\n        let o = 0;\n        this.childNodes.forEach((node) => {\n            if (node.nodeType === NodeType.TEXT_NODE) {\n                if (node.isWhitespace) {\n                    return;\n                }\n                node.rawText = node.trimmedText;\n            }\n            else if (node.nodeType === NodeType.ELEMENT_NODE) {\n                node.removeWhitespace();\n            }\n            this.childNodes[o++] = node;\n        });\n        this.childNodes.length = o;\n        return this;\n    }\n    /**\n     * Query CSS selector to find matching nodes.\n     * @param  {string}         selector Simplified CSS selector\n     * @return {HTMLElement[]}  matching elements\n     */\n    querySelectorAll(selector) {\n        return selectAll(selector, this, {\n            xmlMode: true,\n            adapter: Matcher\n        });\n        // let matcher: Matcher;\n        // if (selector instanceof Matcher) {\n        // \tmatcher = selector;\n        // \tmatcher.reset();\n        // } else {\n        // \tif (selector.includes(',')) {\n        // \t\tconst selectors = selector.split(',');\n        // \t\treturn Array.from(selectors.reduce((pre, cur) => {\n        // \t\t\tconst result = this.querySelectorAll(cur.trim());\n        // \t\t\treturn result.reduce((p, c) => {\n        // \t\t\t\treturn p.add(c);\n        // \t\t\t}, pre);\n        // \t\t}, new Set<HTMLElement>()));\n        // \t}\n        // \tmatcher = new Matcher(selector);\n        // }\n        // interface IStack {\n        // \t0: Node;\t// node\n        // \t1: number;\t// children\n        // \t2: boolean;\t// found flag\n        // }\n        // const stack = [] as IStack[];\n        // return this.childNodes.reduce((res, cur) => {\n        // \tstack.push([cur, 0, false]);\n        // \twhile (stack.length) {\n        // \t\tconst state = arr_back(stack);\t// get last element\n        // \t\tconst el = state[0];\n        // \t\tif (state[1] === 0) {\n        // \t\t\t// Seen for first time.\n        // \t\t\tif (el.nodeType !== NodeType.ELEMENT_NODE) {\n        // \t\t\t\tstack.pop();\n        // \t\t\t\tcontinue;\n        // \t\t\t}\n        // \t\t\tconst html_el = el as HTMLElement;\n        // \t\t\tstate[2] = matcher.advance(html_el);\n        // \t\t\tif (state[2]) {\n        // \t\t\t\tif (matcher.matched) {\n        // \t\t\t\t\tres.push(html_el);\n        // \t\t\t\t\tres.push(...(html_el.querySelectorAll(selector)));\n        // \t\t\t\t\t// no need to go further.\n        // \t\t\t\t\tmatcher.rewind();\n        // \t\t\t\t\tstack.pop();\n        // \t\t\t\t\tcontinue;\n        // \t\t\t\t}\n        // \t\t\t}\n        // \t\t}\n        // \t\tif (state[1] < el.childNodes.length) {\n        // \t\t\tstack.push([el.childNodes[state[1]++], 0, false]);\n        // \t\t} else {\n        // \t\t\tif (state[2]) {\n        // \t\t\t\tmatcher.rewind();\n        // \t\t\t}\n        // \t\t\tstack.pop();\n        // \t\t}\n        // \t}\n        // \treturn res;\n        // }, [] as HTMLElement[]);\n    }\n    /**\n     * Query CSS Selector to find matching node.\n     * @param  {string}         selector Simplified CSS selector\n     * @return {HTMLElement}    matching node\n     */\n    querySelector(selector) {\n        return selectOne(selector, this, {\n            xmlMode: true,\n            adapter: Matcher\n        });\n        // let matcher: Matcher;\n        // if (selector instanceof Matcher) {\n        // \tmatcher = selector;\n        // \tmatcher.reset();\n        // } else {\n        // \tmatcher = new Matcher(selector);\n        // }\n        // const stack = [] as { 0: Node; 1: 0 | 1; 2: boolean }[];\n        // for (const node of this.childNodes) {\n        // \tstack.push([node, 0, false]);\n        // \twhile (stack.length) {\n        // \t\tconst state = arr_back(stack);\n        // \t\tconst el = state[0];\n        // \t\tif (state[1] === 0) {\n        // \t\t\t// Seen for first time.\n        // \t\t\tif (el.nodeType !== NodeType.ELEMENT_NODE) {\n        // \t\t\t\tstack.pop();\n        // \t\t\t\tcontinue;\n        // \t\t\t}\n        // \t\t\tstate[2] = matcher.advance(el as HTMLElement);\n        // \t\t\tif (state[2]) {\n        // \t\t\t\tif (matcher.matched) {\n        // \t\t\t\t\treturn el as HTMLElement;\n        // \t\t\t\t}\n        // \t\t\t}\n        // \t\t}\n        // \t\tif (state[1] < el.childNodes.length) {\n        // \t\t\tstack.push([el.childNodes[state[1]++], 0, false]);\n        // \t\t} else {\n        // \t\t\tif (state[2]) {\n        // \t\t\t\tmatcher.rewind();\n        // \t\t\t}\n        // \t\t\tstack.pop();\n        // \t\t}\n        // \t}\n        // }\n        // return null;\n    }\n    /**\n     * traverses the Element and its parents (heading toward the document root) until it finds a node that matches the provided selector string. Will return itself or the matching ancestor. If no such element exists, it returns null.\n     * @param selector a DOMString containing a selector list\n     */\n    closest(selector) {\n        const mapChild = new Map();\n        let el = this;\n        let old = null;\n        function findOne(test, elems) {\n            let elem = null;\n            for (let i = 0, l = elems.length; i < l && !elem; i++) {\n                const el = elems[i];\n                if (test(el)) {\n                    elem = el;\n                }\n                else {\n                    const child = mapChild.get(el);\n                    if (child) {\n                        elem = findOne(test, [child]);\n                    }\n                }\n            }\n            return elem;\n        }\n        while (el) {\n            mapChild.set(el, old);\n            old = el;\n            el = el.parentNode;\n        }\n        el = this;\n        while (el) {\n            const e = selectOne(selector, el, {\n                xmlMode: true,\n                adapter: {\n                    ...Matcher,\n                    getChildren(node) {\n                        const child = mapChild.get(node);\n                        return child && [child];\n                    },\n                    getSiblings(node) {\n                        return [node];\n                    },\n                    findOne,\n                    findAll() {\n                        return [];\n                    }\n                }\n            });\n            if (e) {\n                return e;\n            }\n            el = el.parentNode;\n        }\n        return null;\n    }\n    /**\n     * Append a child node to childNodes\n     * @param  {Node} node node to append\n     * @return {Node}      node appended\n     */\n    appendChild(node) {\n        // node.parentNode = this;\n        this.childNodes.push(node);\n        node.parentNode = this;\n        return node;\n    }\n    /**\n     * Get first child node\n     * @return {Node} first child node\n     */\n    get firstChild() {\n        return this.childNodes[0];\n    }\n    /**\n     * Get last child node\n     * @return {Node} last child node\n     */\n    get lastChild() {\n        return arr_back(this.childNodes);\n    }\n    /**\n     * Get attributes\n     * @access private\n     * @return {Object} parsed and unescaped attributes\n     */\n    get attrs() {\n        if (this._attrs) {\n            return this._attrs;\n        }\n        this._attrs = {};\n        const attrs = this.rawAttributes;\n        for (const key in attrs) {\n            const val = attrs[key] || '';\n            this._attrs[key.toLowerCase()] = decode(val);\n        }\n        return this._attrs;\n    }\n    get attributes() {\n        const ret_attrs = {};\n        const attrs = this.rawAttributes;\n        for (const key in attrs) {\n            const val = attrs[key] || '';\n            ret_attrs[key] = decode(val);\n        }\n        return ret_attrs;\n    }\n    /**\n     * Get escaped (as-it) attributes\n     * @return {Object} parsed attributes\n     */\n    get rawAttributes() {\n        if (this._rawAttrs) {\n            return this._rawAttrs;\n        }\n        const attrs = {};\n        if (this.rawAttrs) {\n            const re = /\\b([a-z][a-z0-9-_:]*)(?:\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\S+)))?/ig;\n            let match;\n            while ((match = re.exec(this.rawAttrs))) {\n                attrs[match[1]] = match[2] || match[3] || match[4] || null;\n            }\n        }\n        this._rawAttrs = attrs;\n        return attrs;\n    }\n    removeAttribute(key) {\n        const attrs = this.rawAttributes;\n        delete attrs[key];\n        // Update this.attribute\n        if (this._attrs) {\n            delete this._attrs[key];\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attrs).map((name) => {\n            const val = JSON.stringify(attrs[name]);\n            if (val === undefined || val === 'null') {\n                return name;\n            }\n            return `${name}=${val}`;\n        }).join(' ');\n        // Update this.id\n        if (key === 'id') {\n            this.id = '';\n        }\n    }\n    hasAttribute(key) {\n        return key.toLowerCase() in this.attrs;\n    }\n    /**\n     * Get an attribute\n     * @return {string} value of the attribute\n     */\n    getAttribute(key) {\n        return this.attrs[key.toLowerCase()];\n    }\n    /**\n     * Set an attribute value to the HTMLElement\n     * @param {string} key The attribute name\n     * @param {string} value The value to set, or null / undefined to remove an attribute\n     */\n    setAttribute(key, value) {\n        if (arguments.length < 2) {\n            throw new Error('Failed to execute \\'setAttribute\\' on \\'Element\\'');\n        }\n        const k2 = key.toLowerCase();\n        const attrs = this.rawAttributes;\n        for (const k in attrs) {\n            if (k.toLowerCase() === k2) {\n                key = k;\n                break;\n            }\n        }\n        attrs[key] = String(value);\n        // update this.attrs\n        if (this._attrs) {\n            this._attrs[k2] = decode(attrs[key]);\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attrs).map((name) => {\n            const val = this.quoteAttribute(attrs[name]);\n            if (val === 'null' || val === '\"\"') {\n                return name;\n            }\n            return `${name}=${val}`;\n        }).join(' ');\n        // Update this.id\n        if (key === 'id') {\n            this.id = value;\n        }\n    }\n    /**\n     * Replace all the attributes of the HTMLElement by the provided attributes\n     * @param {Attributes} attributes the new attribute set\n     */\n    setAttributes(attributes) {\n        // Invalidate current this.attributes\n        if (this._attrs) {\n            delete this._attrs;\n        }\n        // Invalidate current this.rawAttributes\n        if (this._rawAttrs) {\n            delete this._rawAttrs;\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attributes).map((name) => {\n            const val = attributes[name];\n            if (val === 'null' || val === '\"\"') {\n                return name;\n            }\n            return `${name}=${this.quoteAttribute(String(val))}`;\n        }).join(' ');\n    }\n    insertAdjacentHTML(where, html) {\n        if (arguments.length < 2) {\n            throw new Error('2 arguments required');\n        }\n        const p = parse(html);\n        if (where === 'afterend') {\n            const idx = this.parentNode.childNodes.findIndex((child) => {\n                return child === this;\n            });\n            this.parentNode.childNodes.splice(idx + 1, 0, ...p.childNodes);\n            p.childNodes.forEach((n) => {\n                if (n instanceof HTMLElement) {\n                    n.parentNode = this.parentNode;\n                }\n            });\n        }\n        else if (where === 'afterbegin') {\n            this.childNodes.unshift(...p.childNodes);\n        }\n        else if (where === 'beforeend') {\n            p.childNodes.forEach((n) => {\n                this.appendChild(n);\n            });\n        }\n        else if (where === 'beforebegin') {\n            const idx = this.parentNode.childNodes.findIndex((child) => {\n                return child === this;\n            });\n            this.parentNode.childNodes.splice(idx, 0, ...p.childNodes);\n            p.childNodes.forEach((n) => {\n                if (n instanceof HTMLElement) {\n                    n.parentNode = this.parentNode;\n                }\n            });\n        }\n        else {\n            throw new Error(`The value provided ('${where}') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'`);\n        }\n        // if (!where || html === undefined || html === null) {\n        // \treturn;\n        // }\n    }\n    get nextSibling() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            let i = 0;\n            while (i < children.length) {\n                const child = children[i++];\n                if (this === child) {\n                    return children[i] || null;\n                }\n            }\n            return null;\n        }\n    }\n    get nextElementSibling() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            let i = 0;\n            let find = false;\n            while (i < children.length) {\n                const child = children[i++];\n                if (find) {\n                    if (child instanceof HTMLElement) {\n                        return child || null;\n                    }\n                }\n                else if (this === child) {\n                    find = true;\n                }\n            }\n            return null;\n        }\n    }\n    get classNames() {\n        return this.classList.toString();\n    }\n}\n// https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\nconst kMarkupPattern = /<!--[^]*?(?=-->)-->|<(\\/?)([a-z][-.:0-9_a-z]*)\\s*([^>]*?)(\\/?)>/ig;\n// <(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\n// <([a-z][-.:0-9_a-z]*)\\s*\\/>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>|<(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\nconst kAttributePattern = /(^|\\s)(id|class)\\s*=\\s*(\"([^\"]*)\"|'([^']*)'|(\\S+))/ig;\nconst kSelfClosingElements = {\n    area: true,\n    AREA: true,\n    base: true,\n    BASE: true,\n    br: true,\n    BR: true,\n    col: true,\n    COL: true,\n    hr: true,\n    HR: true,\n    img: true,\n    IMG: true,\n    input: true,\n    INPUT: true,\n    link: true,\n    LINK: true,\n    meta: true,\n    META: true,\n    source: true,\n    SOURCE: true,\n    embed: true,\n    EMBED: true,\n    param: true,\n    PARAM: true,\n    track: true,\n    TRACK: true,\n    wbr: true,\n    WBR: true\n};\nconst kElementsClosedByOpening = {\n    li: { li: true, LI: true },\n    LI: { li: true, LI: true },\n    p: { p: true, div: true, P: true, DIV: true },\n    P: { p: true, div: true, P: true, DIV: true },\n    b: { div: true, DIV: true },\n    B: { div: true, DIV: true },\n    td: { td: true, th: true, TD: true, TH: true },\n    TD: { td: true, th: true, TD: true, TH: true },\n    th: { td: true, th: true, TD: true, TH: true },\n    TH: { td: true, th: true, TD: true, TH: true },\n    h1: { h1: true, H1: true },\n    H1: { h1: true, H1: true },\n    h2: { h2: true, H2: true },\n    H2: { h2: true, H2: true },\n    h3: { h3: true, H3: true },\n    H3: { h3: true, H3: true },\n    h4: { h4: true, H4: true },\n    H4: { h4: true, H4: true },\n    h5: { h5: true, H5: true },\n    H5: { h5: true, H5: true },\n    h6: { h6: true, H6: true },\n    H6: { h6: true, H6: true }\n};\nconst kElementsClosedByClosing = {\n    li: { ul: true, ol: true, UL: true, OL: true },\n    LI: { ul: true, ol: true, UL: true, OL: true },\n    a: { div: true, DIV: true },\n    A: { div: true, DIV: true },\n    b: { div: true, DIV: true },\n    B: { div: true, DIV: true },\n    i: { div: true, DIV: true },\n    I: { div: true, DIV: true },\n    p: { div: true, DIV: true },\n    P: { div: true, DIV: true },\n    td: { tr: true, table: true, TR: true, TABLE: true },\n    TD: { tr: true, table: true, TR: true, TABLE: true },\n    th: { tr: true, table: true, TR: true, TABLE: true },\n    TH: { tr: true, table: true, TR: true, TABLE: true }\n};\nconst frameflag = 'documentfragmentcontainer';\n/**\n * Parses HTML and returns a root element\n * Parse a chuck of HTML source.\n * @param  {string} data      html\n * @return {HTMLElement}      root element\n */\nexport function base_parse(data, options = { lowerCaseTagName: false, comment: false }) {\n    const elements = options.blockTextElements || {\n        script: true,\n        noscript: true,\n        style: true,\n        pre: true\n    };\n    const element_names = Object.keys(elements);\n    const kBlockTextElements = element_names.map((it) => {\n        return new RegExp(it, 'i');\n    });\n    const kIgnoreElements = element_names.filter((it) => {\n        return elements[it];\n    }).map((it) => {\n        return new RegExp(it, 'i');\n    });\n    function element_should_be_ignore(tag) {\n        return kIgnoreElements.some((it) => {\n            return it.test(tag);\n        });\n    }\n    function is_block_text_element(tag) {\n        return kBlockTextElements.some((it) => {\n            return it.test(tag);\n        });\n    }\n    const root = new HTMLElement(null, {}, '', null);\n    let currentParent = root;\n    const stack = [root];\n    let lastTextPos = -1;\n    let match;\n    // https://github.com/taoqf/node-html-parser/issues/38\n    data = `<${frameflag}>${data}</${frameflag}>`;\n    while ((match = kMarkupPattern.exec(data))) {\n        if (lastTextPos > -1) {\n            if (lastTextPos + match[0].length < kMarkupPattern.lastIndex) {\n                // if has content\n                const text = data.substring(lastTextPos, kMarkupPattern.lastIndex - match[0].length);\n                currentParent.appendChild(new TextNode(text, currentParent));\n            }\n        }\n        lastTextPos = kMarkupPattern.lastIndex;\n        if (match[2] === frameflag) {\n            continue;\n        }\n        if (match[0][1] === '!') {\n            // this is a comment\n            if (options.comment) {\n                // Only keep what is in between <!-- and -->\n                const text = data.substring(lastTextPos - 3, lastTextPos - match[0].length + 4);\n                currentParent.appendChild(new CommentNode(text, currentParent));\n            }\n            continue;\n        }\n        if (options.lowerCaseTagName) {\n            match[2] = match[2].toLowerCase();\n        }\n        if (!match[1]) {\n            // not </ tags\n            const attrs = {};\n            for (let attMatch; (attMatch = kAttributePattern.exec(match[3]));) {\n                attrs[attMatch[2].toLowerCase()] = attMatch[4] || attMatch[5] || attMatch[6];\n            }\n            const tagName = currentParent.rawTagName;\n            if (!match[4] && kElementsClosedByOpening[tagName]) {\n                if (kElementsClosedByOpening[tagName][match[2]]) {\n                    stack.pop();\n                    currentParent = arr_back(stack);\n                }\n            }\n            // ignore container tag we add above\n            // https://github.com/taoqf/node-html-parser/issues/38\n            currentParent = currentParent.appendChild(new HTMLElement(match[2], attrs, match[3], null));\n            stack.push(currentParent);\n            if (is_block_text_element(match[2])) {\n                // a little test to find next </script> or </style> ...\n                const closeMarkup = `</${match[2]}>`;\n                const index = (() => {\n                    if (options.lowerCaseTagName) {\n                        return data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex);\n                    }\n                    return data.indexOf(closeMarkup, kMarkupPattern.lastIndex);\n                })();\n                if (element_should_be_ignore(match[2])) {\n                    let text;\n                    if (index === -1) {\n                        // there is no matching ending for the text element.\n                        text = data.substr(kMarkupPattern.lastIndex);\n                    }\n                    else {\n                        text = data.substring(kMarkupPattern.lastIndex, index);\n                    }\n                    if (text.length > 0) {\n                        currentParent.appendChild(new TextNode(text, currentParent));\n                    }\n                }\n                if (index === -1) {\n                    lastTextPos = kMarkupPattern.lastIndex = data.length + 1;\n                }\n                else {\n                    lastTextPos = kMarkupPattern.lastIndex = index + closeMarkup.length;\n                    match[1] = 'true';\n                }\n            }\n        }\n        if (match[1] || match[4] || kSelfClosingElements[match[2]]) {\n            // </ or /> or <br> etc.\n            while (true) {\n                if (currentParent.rawTagName === match[2]) {\n                    stack.pop();\n                    currentParent = arr_back(stack);\n                    break;\n                }\n                else {\n                    const tagName = currentParent.tagName;\n                    // Trying to close current tag, and move on\n                    if (kElementsClosedByClosing[tagName]) {\n                        if (kElementsClosedByClosing[tagName][match[2]]) {\n                            stack.pop();\n                            currentParent = arr_back(stack);\n                            continue;\n                        }\n                    }\n                    // Use aggressive strategy to handle unmatching markups.\n                    break;\n                }\n            }\n        }\n    }\n    return stack;\n}\n/**\n * Parses HTML and returns a root element\n * Parse a chuck of HTML source.\n */\nexport function parse(data, options = { lowerCaseTagName: false, comment: false }) {\n    const stack = base_parse(data, options);\n    const [root] = stack;\n    while (stack.length > 1) {\n        // Handle each error elements.\n        const last = stack.pop();\n        const oneBefore = arr_back(stack);\n        if (last.parentNode && last.parentNode.parentNode) {\n            if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {\n                // Pair error case <h3> <h3> handle : Fixes to <h3> </h3>\n                oneBefore.removeChild(last);\n                last.childNodes.forEach((child) => {\n                    oneBefore.parentNode.appendChild(child);\n                });\n                stack.pop();\n            }\n            else {\n                // Single error  <div> <h3> </div> handle: Just removes <h3>\n                oneBefore.removeChild(last);\n                last.childNodes.forEach((child) => {\n                    oneBefore.appendChild(child);\n                });\n            }\n        }\n        else {\n            // If it's final element just skip.\n        }\n    }\n    // response.childNodes.forEach((node) => {\n    // \tif (node instanceof HTMLElement) {\n    // \t\tnode.parentNode = null;\n    // \t}\n    // });\n    return root;\n}\n"]},"metadata":{},"sourceType":"module"}