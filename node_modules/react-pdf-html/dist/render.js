"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyStylesheets = exports.renderElements = exports.renderElement = exports.bucketElements = exports.hasBlockContent = void 0;
const react_1 = __importDefault(require("react"));
const renderers_1 = __importStar(require("./renderers"));
const renderer_1 = require("@react-pdf/renderer");
const parse_1 = __importDefault(require("./parse"));
const styles_1 = require("./styles");
const tags_1 = require("./tags");
const convertEntities = (input) => {
    const entities = [
        ['amp', '&'],
        ['apos', "'"],
        ['#x27', "'"],
        ['#x2F', '/'],
        ['#39', "'"],
        ['#47', '/'],
        ['lt', '<'],
        ['gt', '>'],
        ['nbsp', ' '],
        ['quot', '"'],
    ];
    let text = input;
    for (let entity of entities) {
        text = text.replace(new RegExp('&' + entity[0] + ';', 'g'), entity[1]);
    }
    return text;
};
const hasBlockContent = (element) => {
    if (typeof element === 'string') {
        return false;
    }
    if (tags_1.isBlock[element.tag]) {
        return true;
    }
    if (element.content) {
        return !!element.content.find(exports.hasBlockContent);
    }
    return false;
};
exports.hasBlockContent = hasBlockContent;
const ltrim = (text) => text.replace(/^\s+/, '');
const rtrim = (text) => text.replace(/\s+$/, '');
/**
 * Groups all block and non-block elements into buckets so that all non-block elements can be rendered in a parent Text element
 * @param elements Elements to place in buckets of block and non-block content
 * @param collapse
 * @param parentTag
 */
const bucketElements = (elements, collapse, parentTag) => {
    let bucket;
    let hasBlock;
    const buckets = [];
    elements.forEach((element, index) => {
        // clear empty strings between block elements
        if (typeof element === 'string') {
            if (parentTag === 'pre') {
                if (element[0] === '\n') {
                    element = element.substr(1);
                }
                if (element[element.length - 1] === '\n') {
                    element = element.substr(0, element.length - 1);
                }
            }
            else {
                if (collapse && (hasBlock || hasBlock === undefined)) {
                    element = ltrim(element);
                }
                const next = elements[index + 1];
                if (collapse && next && (0, exports.hasBlockContent)(next)) {
                    element = rtrim(element);
                }
            }
            if (element === '') {
                return;
            }
        }
        const block = (0, exports.hasBlockContent)(element);
        if (block !== hasBlock) {
            hasBlock = block;
            bucket = {
                hasBlock,
                content: [],
            };
            buckets.push(bucket);
        }
        bucket.content.push(element);
    });
    return buckets;
};
exports.bucketElements = bucketElements;
const renderElement = (element, stylesheets, renderers, children, index) => {
    if (typeof element === 'string') {
        element = convertEntities(element);
        if (/(\s )|( \s)/.test(element)) {
            // hack to avoid collapsing sequential spaces
            return element
                .split(/(\s{2,})/g)
                .reduce((strings, string, index) => string === ''
                ? strings
                : strings.concat(index % 2 ? string.split('') : string), []);
        }
        return element;
    }
    let Element = renderers[element.tag];
    if (!Element) {
        if (!(element.tag in tags_1.isBlock)) {
            // Unknown element, do nothing
            console.warn(`Excluding "${element.tag}" because it has no renderer`);
            Element = renderers_1.renderNoop;
        }
        else {
            Element = (0, exports.hasBlockContent)(element) ? renderers_1.renderBlock : renderers_1.renderInline;
        }
    }
    return (react_1.default.createElement(Element, { key: index, style: element.style, children: children, element: element, stylesheets: stylesheets }));
};
exports.renderElement = renderElement;
const collapseWhitespace = (string) => string.replace(/(\s+)/g, ' ');
const renderElements = (elements, options, parentTag) => {
    const buckets = (0, exports.bucketElements)(elements, options.collapse, parentTag);
    return buckets.map((bucket, bucketIndex) => {
        const rendered = bucket.content.map((element, index) => {
            if (typeof element === 'string') {
                if (options.collapse) {
                    element = collapseWhitespace(element);
                }
                return (0, exports.renderElement)(element, options.stylesheets, options.renderers, undefined, index);
            }
            return (0, exports.renderElement)(element, options.stylesheets, options.renderers, (0, exports.renderElements)(element.content, element.tag === 'pre' ? Object.assign(Object.assign({}, options), { collapse: false }) : options, element.tag), index);
        });
        const parentIsBlock = parentTag && tags_1.isBlock[parentTag] === false;
        return bucket.hasBlock || parentIsBlock ? (react_1.default.createElement(react_1.default.Fragment, { key: bucketIndex }, rendered)) : (react_1.default.createElement(renderer_1.Text, { key: bucketIndex }, rendered));
    });
};
exports.renderElements = renderElements;
const applyStylesheets = (stylesheets, rootElement) => {
    stylesheets.forEach((stylesheet) => {
        for (const selector of Object.keys(stylesheet)) {
            const elements = rootElement.querySelectorAll(selector);
            elements.forEach((element) => {
                element.style.push(stylesheet[selector]);
            });
        }
    });
};
exports.applyStylesheets = applyStylesheets;
const renderHtml = (text, options) => {
    const defaultFontSize = 18;
    const fontSizeStyle = { fontSize: defaultFontSize };
    const styles = options.style
        ? Array.isArray(options.style)
            ? options.style
            : [options.style]
        : [];
    styles.forEach((style) => {
        if (!style) {
            return;
        }
        if (typeof style.fontSize === 'number') {
            fontSizeStyle.fontSize = style.fontSize;
        }
        if (typeof style.fontSize === 'string' && style.fontSize.endsWith('px')) {
            fontSizeStyle.fontSize = parseInt(style.fontSize, 10);
        }
    });
    const baseStyles = (0, styles_1.createHtmlStylesheet)(fontSizeStyle.fontSize, options.resetStyles);
    const parsed = (0, parse_1.default)(text);
    const stylesheets = options.stylesheet
        ? Array.isArray(options.stylesheet)
            ? options.stylesheet
            : [options.stylesheet]
        : [];
    const opts = Object.assign(Object.assign({ collapse: true, resetStyles: false }, options), { renderers: Object.assign(Object.assign({}, renderers_1.default), options.renderers), stylesheets: [baseStyles, ...stylesheets, ...parsed.stylesheets] });
    (0, exports.applyStylesheets)(opts.stylesheets, parsed.rootElement);
    return (react_1.default.createElement(renderer_1.View, { style: Object.assign(Object.assign({}, styles), fontSizeStyle) }, (0, exports.renderElements)(parsed.rootElement.content, opts)));
};
exports.default = renderHtml;
//# sourceMappingURL=render.js.map